<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Gaizhedu">





<title>Python 中的函数 | Gaizhedu的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 8.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Gaizhedu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">文章</a>
                
                <a class="menu-item" href="/tag">标签</a>
                
                <a class="menu-item" href="/about">关于本站</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Gaizhedu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">文章</a>
                
                <a class="menu-item" href="/tag">标签</a>
                
                <a class="menu-item" href="/about">关于本站</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开全部</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">跳转底部</a>
    </div>
</div>

<script>

    var tocI18n = {
        expandAll: '展开全部',  // EJS 写法，NJK 用 {{ __('toc_expand_all') }}
        collapseAll: '全部折叠' // 先在 zh-CN.yml 里加这个键
    };

    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? tocI18n.expandAll : tocI18n.collapseAll;
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python 中的函数</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Gaizhedu</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">2025-07-17&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是Python中的一个重要组成部分，合理运用函数可以解决很多问题</p>
<h2 id="函数的基本内容"><a href="#函数的基本内容" class="headerlink" title="函数的基本内容"></a>函数的基本内容</h2><p>为了更好的学习函数的相关内容，这里将简单介绍函数，如果已经有一部分基础，可以选择直接跳过这部分</p>
<p>这里就不复杂介绍函数是什么了，简单说就是一个可以重复执行的代码块</p>
<h3 id="创建一个新的函数"><a href="#创建一个新的函数" class="headerlink" title="创建一个新的函数"></a>创建一个新的函数</h3><p>如何创建一个函数，其实方法很简单，直接给出例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_function</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<p>在上面的例子中<code>def</code>就是创建函数的语法，而后面的<code>a_function</code>就是这个函数的名字，后面括号内的<code>name</code>是这个函数的一个参数</p>
<p>函数内的<code>return</code>指的是把后面的<code>name</code>返回给调用这个函数的人，这个return语句可以不主动填写，这时候相当于填写了<code>return None</code></p>
<p>这时候就有人要问了，这个返回给调用这个函数的人是什么意思呢？</p>
<p>我们简单举个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus_fun</span>(<span class="params">v1, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> v1 + v2</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(plus_fun(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，变量a和变量b作为参数被传进了函数<code>plus_fun</code>里面，其中<code>v1</code>对应的是<code>a</code>，<code>v2</code>对应的是<code>b</code></p>
<p>而不难发现，<code>print</code>的结果刚好是<code>return</code>后面的<code>v1 + v2</code>的结果</p>
<p>所以，<code>return</code>返回的结果是后面跟着的东西</p>
<p>而这里<code>print</code>语句中，里面使用了<code>plus_fun()</code>函数，所以<code>print</code>语句中输出的东西是这个函数返回的结果</p>
<h3 id="向函数里面传值"><a href="#向函数里面传值" class="headerlink" title="向函数里面传值"></a>向函数里面传值</h3><p>我们已经学会了怎么创建一个函数，接下来要知道如何往一个函数里面传参数</p>
<p>这时候就有人要问了，传参数有什么用呢</p>
<p>举一个简单的例子：<br>这是一个函数，数学意义上的：<br>$f(x) &#x3D; x^2$</p>
<p>这里的传参相当于那数字带入这里的x</p>
<p>同时也说明了函数的作用：可以重复执行的代码块，只要传入参数</p>
<p>说回正题，要如何向一个函数传入参数呢？</p>
<p>首先我们要确定能传入多少参数，这由函数后面的括号里面的值的多少决定</p>
<p>以上面的<code>plus_fun()</code>为例，这个函数一共有两个参数，一个为<code>v1</code> 另一个为<code>v2</code>，那么在传入的时候，就只能传入两个参数</p>
<p>而传入参数的方法也很简单，只需要在使用函数的时候在括号里面加上参数即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_fun</span>(<span class="params">list_1, list_2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是第一个列表：&quot;</span>,list_1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是第二个列表：&quot;</span>,list_2)</span><br><span class="line">    <span class="keyword">return</span> list_1 + list_2</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(a_fun(a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：这是第一个列表： [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># 这是第二个列表： [6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，传入值的顺序，是与函数定义是后面的参数的顺序相一致的</p>
<p>当然，如果你不想按顺序传入，只需要指定是哪几个值是什么即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_fun</span>(<span class="params">list_1, list_2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是第一个列表：&quot;</span>,list_1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是第二个列表：&quot;</span>,list_2)</span><br><span class="line">    <span class="keyword">return</span> list_1 + list_2</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(a_fun(list_2 = b,list_1 = a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：这是第一个列表： [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># 这是第二个列表： [6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>
<p>可以发现，这里是<code>b</code>先传入，但是由于已经说明了哪个值对应传入的哪几个值，所以输出的结果是不受顺序改变的</p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>这时候就有人要问了，如果要的值是不变的，那怎么办？</p>
<p>解决方法也很简单，只需要在创建函数的时候将值说明即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">introduct</span>(<span class="params">name,age=<span class="number">18</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;学生：&quot;</span>,name,<span class="string">&quot;年龄：&quot;</span>,age)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;小明&quot;</span></span><br><span class="line">b = <span class="string">&quot;小华&quot;</span></span><br><span class="line"></span><br><span class="line">introduct(a)</span><br><span class="line">introduct(b,<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：学生： 小明 年龄： 18</span></span><br><span class="line"><span class="comment"># 学生： 小华 年龄： 19</span></span><br></pre></td></tr></table></figure>
<p>这里可以发现，第一个小明在传入时没有填入<code>age</code>的值，但由于函数在定义时已经将<code>age</code>的值填好了，默认为18，所以不会报错</p>
<p>而第二个例子小华，在传入时重新给了一个值，使得原来函数定义时的值被覆写了，这也说明了在创建函数时写入的值可以被后面使用函数时改变</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>接下来来讲讲可变参数，也就是<code>*args</code>和<code>**kwargs</code></p>
<p>*args：接收任意数量的位置参数（元组）<br>**kwargs：接收任意数量的关键字参数（字典）</p>
<p>这里简单举个例子说明</p>
<p>首先是<code>*args</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_tuple</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add_tuple(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：(1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到：使用<code>*args</code>可以同时传进多个参数（例如这里的<code>1,2,3,4,5</code>）</p>
<p>同时，还将原本的参数打包成了一个元组（见输出的第一条结果）</p>
<p>这样有什么好处呢？当你的参数数量不确定的时候，便可以直接将所有的参数全部用<code>*args</code>传进函数，让函数自己打包，使得代码更加简洁</p>
<p>此外，<code>*args</code>还可以统一处理传进的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(args)</span><br><span class="line"></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">b = (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a_func(*a,*b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：55</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里两个元组都被<code>*args</code>统一传进了函数</p>
<p>还有一个点就是<code>*args</code>的名字时可以改变的，比如想叫<code>*exp</code>也是可以的，<strong>但是星号一定要保留</strong>，但约定俗成还是统一叫做<code>*args</code></p>
<h5 id="注意内容"><a href="#注意内容" class="headerlink" title="注意内容"></a>注意内容</h5><p>在使用<code>*args</code>的时候还有一些注意的点：</p>
<p>另外一个就是在使用<code>*args</code>的时候要注意<strong>位置</strong></p>
<p>下面直接给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">e_fun</span>(<span class="params">a,b,*args</span>):</span><br><span class="line">    <span class="keyword">return</span> (a + <span class="built_in">sum</span>(args)) * b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(e_fun(<span class="number">7</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：130</span></span><br><span class="line"><span class="comment"># 也就是 [7 + (1 + 2 + 3)] * 10 = 130</span></span><br></pre></td></tr></table></figure>
<p>但如果调换了位置的话（<code>b</code>与<code>*args</code>调换），由于<code>*args</code>可以接受任意数量的参数，所以这里会连带把<code>b</code>的值给打包，这就导致了缺少一个参数的值</p>
<p>所以，<strong>在定义函数时，可变参数（*arg）要放在位置参数（a, b）之后</strong></p>
<p>接下来是<code>**kwargs</code><br><code>**kwargs</code>是一个特殊的参数，作用是把传进的 <strong>关键字参数</strong> 打包成字典</p>
<p>什么关键字参数？大概长这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">**kwarys</span>):</span><br><span class="line">    <span class="keyword">return</span> kwarys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a_func(name=<span class="string">&quot;李华&quot;</span>,age=<span class="string">&quot;18&quot;</span>,height=<span class="number">170</span>,weight=<span class="number">59</span>))</span><br></pre></td></tr></table></figure>
<p>这里引用函数时括号里面的<code>name</code>、<code>age</code>、<code>height</code>、<code>weight</code>就是关键字参数</p>
<p>上面的输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李华&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">170</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">59</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，返回的结果是一个字典</p>
<p>那么这个参数有什么优点呢？</p>
<p>优点在于其可以处理任意数量的关键字参数，不必担心传入时出现多余的参数而无法处理</p>
<p>与上文的<code>*args</code>一样，<code>**kwargs</code>同样支持自定义名称，只要把<code>**</code>保留皆可</p>
<p>另外一个用法是，可以用<code>**</code>解包一个字典</p>
<p>这里给出例子说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">18</span>&#125;</span><br><span class="line">a_func(**person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：名字：小明，年龄：18</span></span><br></pre></td></tr></table></figure>
<p>这里相当于把字典<code>person</code>解包成两个参数<code>name</code>和<code>age</code>，之后再传进函数内</p>
<h5 id="注意内容-1"><a href="#注意内容-1" class="headerlink" title="注意内容"></a>注意内容</h5><p>与上文的<code>*args</code>一样，定义函数时若使用该可变参数同样要注意位置</p>
<p>这里的<code>*kwarys</code>要放到最后面</p>
<h4 id="返回结果与-return-语句"><a href="#返回结果与-return-语句" class="headerlink" title="返回结果与 return 语句"></a>返回结果与 return 语句</h4><p>在Python的函数中，如果你想要返回函数的结果，可以使用<code>return</code>语句</p>
<p>在之前的内容中，也已经提及了大量的例子，这些例子中都包含了<code>return</code>语句</p>
<p>接下来来详细介绍一下：</p>
<p><strong>1.无返回值</strong><br>无返回值也就是不返回任何东西，如果没有填写<code>return</code>语句，则自动视为无返回值</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line"></span><br><span class="line">return_func = a_func()</span><br><span class="line"><span class="built_in">print</span>(return_func)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：Hello World!</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到，使用<code>print</code>语句打印函数的输出结果是<code>None</code>，也就是无返回值</p>
<p><strong>2.返回单个值</strong><br><code>return</code>可以返回很多东西，包括一个值，一条式子等都是可以的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a, b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">o_func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一条式子的结果是：&quot;</span>,a_func(a, b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二条式子的结果是：&quot;</span>,o_func(a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：第一条式子的结果是： 3</span></span><br><span class="line"><span class="comment"># 第二条式子的结果是： 3</span></span><br></pre></td></tr></table></figure>

<p>接下来是返回一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> name, age</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;李华&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(a_func(name, age))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a_func(name, age)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：(&#x27;李华&#x27;, 18)</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里返回的类型为<code>tuple</code>，也就是<strong>元组</strong></p>
<p>接下来是列表和字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">l_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, a)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">d_func</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span> : name,</span><br><span class="line">        <span class="string">&quot;age&quot;</span> : age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">number = <span class="number">5</span></span><br><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(l_func(number), <span class="built_in">type</span>(l_func(number)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;名字是&quot;</span>,d_func(name, age)[<span class="string">&quot;name&quot;</span>],<span class="string">&quot;年龄是&quot;</span>,d_func(name,age)[<span class="string">&quot;age&quot;</span>], <span class="built_in">type</span>(d_func(name, age)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 4, 9, 16] &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 名字是 小明 年龄是 18 &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，返回的结果分别是列表（list）以及字典（dict）</p>
<h3 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h3><p>接下来来讲讲作用域和闭包：</p>
<p><strong>作用域</strong><br>作用域指的是程序中变量、函数和对象的可访问范围。举个鲜明的例子：假设你在自己的房间里面放一个箱子，那么只有在这个房间的人才能用这个箱子，此时便叫做<strong>局部作用域</strong>，但如果把这个箱子放到公共的地方，那么所有人都能用这个箱子，此时便叫做<strong>全局作用域</strong></p>
<p>作用域一共有以下的种类：</p>
<table>
    <thead>
        <tr>
            <th>名称</th>
            <th>变量位置</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>全局作用域（Global）</td>
            <td>位于<strong>模块顶部</strong>的变量，不在任何函数，类里面</td>
        </tr>
        <tr>
            <td>局部作用域（Local）</td>
            <td>变量位于函数内部，并且只能在该函数里面可见</td>
        </tr>
        <tr>
            <td>嵌套作用域（Enclosing）</td>
            <td>嵌套作用域的出现条件是位于嵌套函数中，此时内部函数可以访问外部函数的变量，注意这里的对象是内部函数而非外部函数</td>
        </tr>
        <tr>
            <td>内置作用域（Built-in）</td>
            <td>Python里面内置的函数或者变量</td>
        </tr>
    </tbody>
</table>

<p>下面为每个作用域给出实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;我位于模块最顶部，是全局作用域&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    b = <span class="string">&quot;我是一个函数中的变量，所以位于局部作用域&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>():</span><br><span class="line">        c = <span class="string">&quot;我是一个嵌套函数中内部函数的一个变量，所以位于嵌套作用域&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line">    b_func()</span><br><span class="line">    <span class="comment"># 这里如果试图调用内部函数的变量c则会报错，因为变量c位于嵌套作用域</span></span><br><span class="line">    <span class="comment"># 而现在所处的位置是一个嵌套函数中的外部函数，不位于内部函数中，所以没法使用变量c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 print 属于内置作用域，因为 print 是一个内置函数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>对于全局作用域而言，在当前模块（说白了就是在这个文件里面）下，你可以在任意地方访问，若位于其他模块，则需要使用<code>import</code>语句来导入该变量</p>
<p>对于局部作用域而言，只能在函数内部访问，并且函数结束时变量自动销毁，不可复用</p>
<p>对于嵌套作用域而言，有且仅有内部函数可以访问，如果需要修改外部函数的变量，可以使用<code>nonlocal</code>语句后对闭包作用域（外部函数）的变量进行修改</p>
<p>下面给出实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    a = <span class="string">&quot;我现在位于局部作用域&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a = <span class="string">&quot;现在已使用 nonlocal 语句修改位于闭包作用域（外部函数 a_func）的变量a&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    b_func()</span><br><span class="line"></span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>

<p>这里额外再介绍一下Python中查找变量的规则：<strong>LEGB规则</strong></p>
<p>L：Local<br>E：Enclosing<br>G：Global<br>B：Built-in</p>
<p>这里的L，也就是Local指的是Python先在函数内部查找变量</p>
<p>而E，指的是Enclosing，也就是在函数内部查找不到变量后便在外部函数里面查找</p>
<p>若还是找不到，那便是G，也就是Global，会在全局作用域里面查找</p>
<p>若以上都没有，则会在B，也就是Bulit-in，在内置作用域里面查找</p>
<p>这就是LEGB规则</p>
<hr>
<p><strong>闭包</strong><br>闭包是嵌套在外部函数内部的内部函数，它的特点是在外部函数结束时，作为内部函数中的变量可以被储存起来，不会被销毁</p>
<p>需要注意的是，只有被闭包引用的变量才不会被销毁，而未被引用的变量是会被销毁的，同样的道理，闭包内部的变量也会随着函数的结束而被销毁，除非闭包内部还有另一个函数来引用闭包内部的变量</p>
<p>下面给出例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> b_func</span><br><span class="line"></span><br><span class="line">func = a_func()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们可以看到内部函数<code>b_func</code>引用了外部函数<code>a_func</code>的一个变量a，此时内部函数<code>b_func</code>就形成了一个闭包</p>
<p>而在后边的 <code>return b_func</code> 中，这里的函数已经结束，外部函数<code>a_func</code>已经被销毁，但是由于内部函数是个闭包，导致了变量a被保存起来<br>这也是为什么后面<code>func()</code>可以正常输出a的值的原因</p>
<p>需要注意一点的是，这里内部函数在引用外部函数的变量时不需要加<code>nonlocal</code>，但是如果内部函数出现了修改变量的情况，则需要加<code>nonlocal</code>，否则内部函数会将变量认为是一个新的变量</p>
<hr>
<h2 id="参数（进阶）"><a href="#参数（进阶）" class="headerlink" title="参数（进阶）"></a>参数（进阶）</h2><h3 id="位置参数与关键字参数"><a href="#位置参数与关键字参数" class="headerlink" title="位置参数与关键字参数"></a>位置参数与关键字参数</h3><p>在之前的内容已经稍微讲过了有关位置参数和关键字参数的内容，接下来来细致介绍一下相关内容</p>
<p>位置参数和关键字参数都是Python中用来向函数传递参数的一种方式</p>
<p>首先是<strong>位置参数</strong></p>
<p>位置参数指的是 <em>按照参数定义的顺序依次传递的参数</em></p>
<p>具体的特点是：传递参数时按照定义的顺序传递，不可以调换顺序，并且不可以省略，除非有默认值</p>
<p>接下来给出具体例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name,age,work</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你的名字叫做<span class="subst">&#123;name&#125;</span>，年龄为<span class="subst">&#123;age&#125;</span>，工作为<span class="subst">&#123;work&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_func(<span class="string">&quot;李华&quot;</span>,<span class="string">&quot;28&quot;</span>,<span class="string">&quot;程序员&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：你的名字叫做李华，年龄为28，工作为程序员</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，函数 <code>a_func</code> 被引用时后面带着的三个参数就被称为位置参数，可以看到，三个参数被依次传递到函数内部</p>
<p>这里如果试图调换顺序，则会使得参数的位置错位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name,age,work</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你的名字叫做<span class="subst">&#123;name&#125;</span>，年龄为<span class="subst">&#123;age&#125;</span>，工作为<span class="subst">&#123;work&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_func(<span class="string">&quot;28&quot;</span>,<span class="string">&quot;程序员&quot;</span>,<span class="string">&quot;李华&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：你的名字叫做28，年龄为程序员，工作为李华</span></span><br></pre></td></tr></table></figure>

<p>因此，<strong>在使用位置参数时一定要注意参数的传入顺序</strong></p>
<hr>
<p>接下来是<strong>关键字参数</strong>，正如这个参数的名字一样，关键字参数可以通过关键词来传递参数，这样的好处是当你在传递参数时，可以不考虑传递的顺序，只需要考虑关键词是否对应即可</p>
<p>下面给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name,age,work</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你的名字叫做<span class="subst">&#123;name&#125;</span>，年龄为<span class="subst">&#123;age&#125;</span>，工作为<span class="subst">&#123;work&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">a_func(age = <span class="string">&quot;28&quot;</span>,work = <span class="string">&quot;程序员&quot;</span>,name = <span class="string">&quot;李华&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：你的名字叫做李华，年龄为28，工作为程序员</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过使用关键字参数，即使传递参数时的顺序不是定义函数时的顺序，但每个参数都被正确的传递了，这也体现了关键字参数中不依赖顺序的特点</p>
<p>在使用关键字参数的时候，还可以通过默认值来省略部分参数</p>
<p>下面照例给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, work, age=<span class="number">20</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你的名字叫做<span class="subst">&#123;name&#125;</span>，年龄为<span class="subst">&#123;age&#125;</span>，工作为<span class="subst">&#123;work&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_func(work=<span class="string">&quot;程序员&quot;</span>, name=<span class="string">&quot;李华&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：你的名字叫做李华，年龄为20，工作为程序员</span></span><br></pre></td></tr></table></figure>

<p>这个例子就是使用了默认值，在函数刚定义的时候将默认值声明皆可</p>
<p>在声明后在引用函数时便可以不导入相对应的值</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>在使用关键字参数的默认值时，要注意声明的时候要把默认值放到参数最后面的位置<br>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, age = <span class="number">18</span> ,work</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, work, age = <span class="number">18</span></span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面两个函数中，只有第二个函数才是正确的，而第一个函数因为默认值没有放到最后而导致报错</p>
<h3 id="默认参数的陷阱"><a href="#默认参数的陷阱" class="headerlink" title="默认参数的陷阱"></a>默认参数的陷阱</h3><p>在上面的关键字参数中，我们已经提到过默认值参数这个概念了，接下来来说说有关默认参数里面的陷阱</p>
<p>当默认参数是可变对象（如列表、字典、集合）时，该对象会在函数定义时被创建，并且所有调用共享同一个实例。</p>
<p>例如，当一个函数默认参数值是一个列表，此时如果调用函数将值加进去会导致不符合目标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">list_v , list_a  = []</span>):</span><br><span class="line">    list_a.append(list_v)</span><br><span class="line">    <span class="built_in">print</span>(list_a)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a_func(<span class="number">1</span>)</span><br><span class="line">a_func(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在第二次输出时，并没有按照我们的要求正确输出<code>[2]</code>，而是输出了<code>[1,2]</code><br>要解决这种情况也很简单，只需要将每次的列表初始化即可，下面给出修正后的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">list_v , list_a  = <span class="literal">None</span></span>):</span><br><span class="line">    list_a = []</span><br><span class="line">    list_a.append(list_v)</span><br><span class="line">    <span class="built_in">print</span>(list_a)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a_func(<span class="number">1</span>)</span><br><span class="line">a_func(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"><span class="comment"># [2]</span></span><br></pre></td></tr></table></figure>

<p>这里其实还有一点问题，当用户主动传入一个非空列表时，如果按这里的输入，则会导致列表被重置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">list_v, list_a = <span class="literal">None</span></span>):</span><br><span class="line">    list_a = []</span><br><span class="line">    list_a.append(list_v)</span><br><span class="line">    <span class="built_in">print</span>(list_a)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">100</span>]</span><br><span class="line">a_func(<span class="number">200</span>,list_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[200]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的输出并不是我们预想的<code>[100, 200]</code></p>
<p>这是因为每次调用函数<code>a_func</code>会导致列表重置一次</p>
<p>为了避免这种情况发生，需要在函数里面新增一个判断语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">list_v, list_a = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> list_a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        list_a = []</span><br><span class="line">    list_a.append(list_v)</span><br><span class="line">    <span class="built_in">print</span>(list_a)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">100</span>]</span><br><span class="line">a_func(<span class="number">200</span>,list_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[100, 200]</span></span><br></pre></td></tr></table></figure>
<p>这样就成功避免了传入时原先列表非空的情况</p>
<hr>
<p>另外还有就是关于默认参数的作用域问题，如果默认参数引用了外部变量，则可能导致在后面更新变量时出现变量不更新的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a2 = a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">a_func()</span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">a_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：100</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里在后面更新a的值为200时，后续调用函数并没有改变结果</p>
<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>接下来来讲讲解包，其实这部分的内容已经在可变参数（*args 和 **kwarys）中介绍过了，但还是详细介绍一下</p>
<p>首先是<strong>位置参数解包</strong></p>
<p>当使用<code>*</code>时，你可以将一个列表或者元组拆分成多个元素，然后依次到函数的各个位置参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2, a3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第一个参数是<span class="subst">&#123;a1&#125;</span>，第二个参数是<span class="subst">&#123;a2&#125;</span>，第三个参数是<span class="subst">&#123;a3&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]</span><br><span class="line">a_func(*list_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：第一个参数是111，第二个参数是222，第三个参数是333</span></span><br></pre></td></tr></table></figure>
<p>从这里可以看到，列表的三个位置分别被解包为三个值，并被传到了函数里面</p>
<p>如果不使用解包的做法是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2, a3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第一个参数是<span class="subst">&#123;a1&#125;</span>，第二个参数是<span class="subst">&#123;a2&#125;</span>，第三个参数是<span class="subst">&#123;a3&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]</span><br><span class="line">a_func(list_1[<span class="number">0</span>],list_1[<span class="number">1</span>],list_1[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：第一个参数是111，第二个参数是222，第三个参数是333</span></span><br></pre></td></tr></table></figure>
<p>这里没有使用解包，而是用了传统的列表的项来向函数里面传入值，显然可读性比较低</p>
<p>并且如果列表的数值过多，就会导致需要传入的数值过多，大大影响了代码的可读性</p>
<hr>
<p>接下来是<strong>关键字参数解包</strong></p>
<p>关键字参数解包用于解包字典，之后将解包后的值传进函数，下面直接给出例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">name, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字：<span class="subst">&#123;name&#125;</span>，年龄：<span class="subst">&#123;age&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">person = &#123;<span class="string">&quot;name&quot;</span> :<span class="string">&quot;李华&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span>&#125;</span><br><span class="line">a_func(**person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：名字：李华。年龄：20</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>**person</code>将<code>person</code>这个字典解包成对应的内容</p>
<p>由于这里解包之后的参数为关键字参数，所以可以不用在意传入顺序，只需要确保关键字是正确的皆可</p>
<p>接下来是<strong>混合解包</strong>，说白了就是这两种解包方式可以同时使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2, a3, a4, a5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;列表解包为：<span class="subst">&#123;a1&#125;</span>、<span class="subst">&#123;a2&#125;</span>、<span class="subst">&#123;a3&#125;</span>，字典解包为：<span class="subst">&#123;a4&#125;</span>、<span class="subst">&#123;a5&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dic = &#123;<span class="string">&quot;a4&quot;</span>: <span class="number">4</span>, <span class="string">&quot;a5&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">a_func(*list_1, **dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：列表解包为：1、2、3，字典解包为：4、5</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里分别使用了位置参数解包以及关键字参数解包</p>
<p><code>list_1</code>的三个值分别传递给<code>a1</code>，<code>a2</code>，<code>a3</code>，而字典<code>dic</code>因为为关键字参数，所以被分别传递给各自的参数</p>
<hr>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>接下来来讲讲高阶函数，高阶函数并不是指这个函数更加高级，而是指这个函数可以接受其他函数作为参数，或者将函数当做返回值</p>
<p>这样的函数有很多，之后会逐一介绍</p>
<p>首先我们需要理解第一个高阶函数的概念：<strong>将函数作为参数</strong></p>
<hr>
<h3 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h3><p>正如字面上的意思一致，你可以将一个函数作为一个参数，接下来将用实际例子介绍一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2</span>):</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">a_func, b1, b2</span>):</span><br><span class="line">    <span class="keyword">return</span> a_func(b1 , b2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b_func(a_func,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>
<p>我们来逐一解释这个例子的语句：</p>
<p>首先先从这里看起：<code>print(b_func(a_func,1,2))</code></p>
<p>这里的可以拆分成几部分，分别是：</p>
<ul>
<li>负责打印的<code>print()</code></li>
<li>负责调用函数的<code>b_func()</code></li>
<li>以及传进去的参数<code>a_func,1,2</code></li>
</ul>
<p>之后我们来看一下调用的这个函数内容是什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">a_func, b1, b2</span>):</span><br><span class="line">    <span class="keyword">return</span> a_func(b1 , b2)</span><br></pre></td></tr></table></figure>
<p>很明显，这里是这样的，返回一个以参数<code>a_func</code>的值的函数，其中这个函数传进了两个值（b1和b2）</p>
<p>需要注意的是，这里函数定义时的参数名<code>a_func</code>与我们导入的函数名相同纯属巧合，你可以随便更改这个函数名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">thisisafunc, b1, b2</span>):</span><br><span class="line">    <span class="keyword">return</span> thisisafunc(b1 , b2)</span><br></pre></td></tr></table></figure>
<p>而让我们重新看一下我们传入了什么：很明显是<code>a_func</code>，所以这里就是调用了函数<code>a_func</code></p>
<p>接下来让我们看看<code>a_func</code>函数的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2</span>):</span><br><span class="line">    <span class="keyword">return</span> a1 + a2</span><br></pre></td></tr></table></figure>

<p>很明显，这里是接受两个值：a1和a2，然后返回其相加的值</p>
<p>而这里的a1和a2是是什么？细心往前观察可以看到，就是我们传入的值b1和b2，而这个b1和b2又是什么？再次回看传进函数<code>b_func</code>的值可以发现，b1是1，而b2是2</p>
<p>由此，这里输出的值也就是3了</p>
<hr>
<p>在理解完高阶函数在将函数作为参数这方面的应用后，我们可以写一个简单的四则计算器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">p1, p2</span>):</span><br><span class="line">    <span class="keyword">return</span> p1 + p2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minus</span>(<span class="params">mi1, mi2</span>):</span><br><span class="line">    <span class="keyword">return</span> mi1 - mi2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">mu1, mu2</span>):</span><br><span class="line">    <span class="keyword">return</span> mu1 * mu2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">d1, d2</span>):</span><br><span class="line">    <span class="keyword">return</span> d1 / d2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">operate</span>(<span class="params">func, s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> func(s1, s2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(operate(plus,<span class="number">2</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(operate(minus,<span class="number">9</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(operate(multiply,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(operate(divide,<span class="number">6</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：7</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 30</span></span><br><span class="line"><span class="comment"># 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里其实有个小问题，就是除法没有检测除数不能为0，不过就当忽略这个点了</span></span><br><span class="line"><span class="comment"># 当然如果要加上这个功能只需要在除法的函数那里加上一个检测d2 == 0 即可</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>接下来来讲讲返回函数，也就是返回的结果是个函数，这是什么意思呢，直接举个例子分析一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">b</span>):</span><br><span class="line">            <span class="keyword">return</span> a * b</span><br><span class="line">    <span class="keyword">return</span> b_func</span><br><span class="line"></span><br><span class="line">func = a_func(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：6</span></span><br></pre></td></tr></table></figure>
<p>接下来还是逐一解析语句：</p>
<p>首先看最主要的内容，也就是<code>print(func(3))</code></p>
<p>这里很明显是往<code>func</code>里面塞一个参数<code>3</code>，诶，那<code>func</code>是什么呢？</p>
<p>往上看我们可以得知：哦，原来<code>func</code>代表的是将参数2传进函数<code>a_func</code></p>
<p>这时候我们就已经了解到我们的操作是干什么了，接下来来实际看看函数</p>
<p>首先是第一个，也就是函数<code>a_func</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">b</span>):</span><br><span class="line">            <span class="keyword">return</span> a * b</span><br><span class="line">    <span class="keyword">return</span> b_func</span><br></pre></td></tr></table></figure>
<p>可以看到这个函数里面还有一个函数，我们这里先不考虑，直接看到下面</p>
<p>可以发现返回语句返回的是一个函数，也就是<code>b_func</code>。这里需要注意一点的是，这里函数<code>a_func</code>的参数a已经被我们在一开始调用的时候传入了值（也就是2）</p>
<p>我们看到函数<code>b_func</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">b</span>):</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的函数内容是返回外部参数a和内部变量b的乘积</p>
<p>这里可能就有人要问了：诶，我刚才看用<code>return</code>语句调用函数的时候没有加括号传进值吗，这不是稳报错吗，你是不是写错了</p>
<p>我们可以回看我们一开始的<code>print</code>语句里面写了什么，也就是：<code>func(3)</code>，可以看到这里传进了一个值<code>3</code>，其实这里等价于<code>a_func(2)(3)</code>，在调用函数<code>a_func</code>后返回调用的函数<code>b_func</code>时相当于<code>b_func(3)</code></p>
<p>这里可以看到传入了一个值3，也就是函数<code>b_func</code>里面的位置参数b</p>
<p>所以，这也就是为什么输出结果为6的原因</p>
<hr>
<h3 id="常见内置高阶函数"><a href="#常见内置高阶函数" class="headerlink" title="常见内置高阶函数"></a>常见内置高阶函数</h3><p>在Python中，有很多内置的高阶函数，接下来来逐一介绍</p>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>map()函数的作用是返回一个迭代器，具体如下：<code>map(func, iterable)</code><br>接下来给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list_1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x ** <span class="number">2</span>, s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(list_1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>接下来来逐一解析一下这个语法</p>
<p>首先看一下最主要的函数内容，也就是<code>map(lambda x:x ** 2, s)</code></p>
<p>按照之前map函数的说明，我们可以看到这里的<code>lambda x:x ** 2</code>是这里的<code>func</code></p>
<p>而后面的列表s也就是<code>iterable</code>的内容</p>
<p>这里的<code>map(lambda x:x ** 2, s)</code>也就是将列表s里面的值逐一传入前面的匿名函数，并收集函数的返回值，形成一个迭代器</p>
<p>但如果直接<code>print(list_1)</code>就只会得到一个标识信息，用于显示迭代器（也就是map）对象，但不是一个具体的信息</p>
<p>若想要变成一个列表，则需要用<code>list()</code>转换成列表</p>
<p>此外，如果不需要返回全部的列表，可以以下操作（此处涉及到 <strong>生成器</strong> 的内容）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">list_1 = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,:x ** <span class="number">2</span>, s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">next</span>(list_1) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>此处不多说明，有关<code>next()</code>的语法可到生成器的部分阅读</p>
<h5 id="一些小事项"><a href="#一些小事项" class="headerlink" title="一些小事项"></a>一些小事项</h5><p>如果你细心观察可以发现，诶，这里似乎也可以用列表推导式来实现<code>map()</code>函数的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>([x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>是的，使用列表推导式或者for语句同样可以实现相同的内容，但使用map有一个优势：节省内存</p>
<p>下面给出例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">range</span>(<span class="number">100000</span>)</span><br><span class="line">l = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用列表推导式使用内存：&quot;</span>,sys.getsizeof(l))</span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用map()函数使用内存：&quot;</span>,sys.getsizeof(m))</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    a.append(i ** <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;使用传统for语句使用内存：&quot;</span>,sys.getsizeof(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：使用列表推导式使用内存： 800984</span></span><br><span class="line"><span class="comment"># 使用map()函数使用内存： 48</span></span><br><span class="line"><span class="comment"># 使用传统for语句使用内存： 800984</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里调用了<code>sys</code>库来检测内存使用情况，可以看到，使用map()函数（前提是不转换成列表）只消耗48字节的内存，而其他的方式都消耗了大量的内存</p>
<p>需要注意的一点是，这里如果用 <code>list</code> 将map返回的迭代器转换成列表，消耗的内存是一样的</p>
<p>诶，这里就有人要追问了，那如果消耗的内存是一样的话，那还不是没有用</p>
<p>别急，让我们看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">l = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line">l2 = l[:<span class="number">10</span>]</span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, s)</span><br><span class="line">m2 = <span class="built_in">list</span>((<span class="built_in">next</span>(m) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> l2 == m2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这两者的输出结果完全正确，但是使用<code>map()</code>所需的内存要更少</p>
<p>这是因为使用列表推导式的时候，需要把所有的数据全列出来，再对列表进行切割</p>
<p>而使用迭代器的时候，只有在对列表取项的时候才会列出数据</p>
<p>这里的话列表推导式总列出数据为99999项，而使用迭代器<code>map()</code>则只列出了10项</p>
<hr>
<p>这里需要注意的一个点是，迭代器是一次性的，不可重复使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x+<span class="number">2</span>,s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[3, 4, 5]</span></span><br><span class="line"><span class="comment"># []</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里第二次<code>print(list(a))</code>的时候，输出的是一个空的列表，这说明了迭代器只能使用使用一次</p>
<hr>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>接下来是<code>filter()</code>其格式如下<code>filter(function, iterable)</code></p>
<p>这个函数的作用是对输入的内容进行筛选，筛选规则是：<code>function</code>，而筛选的内容为：<code>iterable</code>，如果筛选的内容符合筛选的规则，则返回<code>True</code></p>
<p>下面给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">range</span>(<span class="number">20</span>)</span><br><span class="line">s = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到，函数<code>filter()</code>将满足条件的值都提取了出来，这里的条件为这个值除2的余数为0，也就是返回偶数</p>
<p>这是可能就有人要问了，诶，使用<code>filter()</code>用来检测值的方法可以通过if语句来实现，那为什么还要用<code>filter()</code>函数呢</p>
<p>首先，<code>filter()</code>跟<code>map()</code>返回的对象是一致的，都是一个<strong>迭代器</strong>，这就导致了，当你需要处理大量数据的时候，使用<code>filter()</code>会相较于使用if语句更省内存，当然，同上文<code>map()</code>一样，迭代器都只能使用一次</p>
<h5 id="其他细节点"><a href="#其他细节点" class="headerlink" title="其他细节点"></a>其他细节点</h5><p><code>filter()</code>在设置过滤时，可以设置成<code>None</code>，此时便可以过滤掉假值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="literal">None</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;字符串&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="literal">None</span>, a)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 2, 3, 4, 5, &#x27;0&#x27;, &#x27;123&#x27;, &#x27;字符串&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里输出的字符串中，将所有假值（0，””，None）都过滤掉了（注：”0”是一个字符串，不是一个假值）</p>
<blockquote>
<p>关于假值的补充：<br>以下内容均为假值:<br>常量：None、False<br>数值：0、0.0、0j（复数零）<br>空序列 &#x2F; 集合：””（空字符串）、[]（空列表）、()（空元组）、{}（空字典 &#x2F; 集合）</p>
</blockquote>
<hr>
<p>还有一个点是，<code>filter()</code>返回的值不一定是严格的布尔值，如果返回的结果也可表示为布尔值，那也一样可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x, a)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 2, 3, 4, 5, -1, -2, -3]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>0</code>并没有返回到结果中，这是因为<code>0</code>也可以表示为<code>False</code>，所以这里并没有返回，而其他值，由于均不为0（也就是不为<code>False</code>），所以都可以成功返回</p>
<hr>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce()</code>是Python中的一个内置的高阶函数，其作用是多次调用实现累计的效果，具体用法如下：<code>reduce(function, iterable[, initializer])</code></p>
<p>这里的<code>function</code>是累计的规则，也就是每次执行什么函数</p>
<p>接下来的<code>iterable</code>是迭代的具体值，后面的<code>initializer</code>是初始值</p>
<p>需要注意的一点是，使用<code>reduce()</code>语句的时候需要导入外部库<code>functools</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br></pre></td></tr></table></figure>

<p>接下来举一个例子来实际说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x,y:x * y,a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：40320</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的输出结果为列表a的各个值的相乘结果（2 * 3 * 4 * 5 * 6 * 7 * 8 &#x3D; 40320）</p>
<p>这也说明了<code>reduce()</code>的核心作用是多次迭代</p>
<p>接下来来讲讲加初始值，顾名思义，也就是第一次的时候使用这个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x,y:x + y,a,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：45</span></span><br></pre></td></tr></table></figure>
<p>可以看到，若不加起始值，则结果为35，但是这里加了起始值，所以还要加上起始值</p>
<hr>
<p>接下来来讲讲一下有意思的操作</p>
<p>由于<code>reduce()</code>可以实现多次调用的效果，所以可以用这个特性实现一些效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">45</span>,<span class="number">5</span>,<span class="number">56</span>,<span class="number">6</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">122</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">4</span>,<span class="number">56</span>]</span><br><span class="line">s = reduce(<span class="keyword">lambda</span> x,y: x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;数列a中的最大值为：<span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：数列a中的最大值为：122</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted()</code>的作用是对任何可迭代对象（如列表、元组、字符串）进行排序，返回一个新的已排序列表，原对象保持不变，使用格式如下：<code>sorted(iterable, *, key=None, reverse=False)</code></p>
<p>接下来来逐一说明一下：<br><code>iterable</code>，也就是要排序的内容，后面的<code>*</code>意味着后面的<code>key</code>和<code>reverse</code>必须要用<strong>关键字参数</strong>，<code>key</code>是指定函数提取出比较的元素，后面的<code>reverse</code>为布尔值，当为<code>False</code>时为升序排列（默认），而为<code>True</code>时就为降序排列</p>
<p>下面给出例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">s = <span class="built_in">sorted</span>(a)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 1, 2, 2, 2, 2, 4, 4, 6, 6, 6, 6, 7, 8, 9, 12]</span></span><br></pre></td></tr></table></figure>
<p>这里给出的例子就是最基本的排序的例子</p>
<p>接下来给出一个使用<code>key</code>提取比较元素的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;directly&quot;</span>, <span class="string">&quot;apart&quot;</span>,<span class="string">&quot;rare&quot;</span>,<span class="string">&quot;withstand&quot;</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">sorted</span>(a,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">t = <span class="built_in">sorted</span>(a,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="comment"># 输出：[&#x27;apart&#x27;, &#x27;directly&#x27;, &#x27;rare&#x27;, &#x27;withstand&#x27;]</span></span><br><span class="line"><span class="comment"># [&#x27;rare&#x27;, &#x27;directly&#x27;, &#x27;withstand&#x27;, &#x27;apart&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第一个例子是以第一个字母的排列顺序为排序标准，而第二个例子是以第二个字母作为排序标准</p>
<p>使用<code>sorted()</code>排序的对象有很多，可以是列表，元组，甚至是字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">62</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">4</span>)</span><br><span class="line">b = <span class="string">&quot;HelloWorld!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 1, 2, 4, 4, 4, 6, 12, 25, 62]</span></span><br><span class="line"><span class="comment"># [&#x27;!&#x27;, &#x27;H&#x27;, &#x27;W&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;r&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里第二个例子的字符串排序标准是<strong>先符号，后大写，最后小写</strong></p>
<p>在说明一些例子后，来具体说明一下参数<code>key</code></p>
<p><code>key</code>排序的规则有很多，可以使用长度<code>len</code>，绝对值<code>abs</code>或者自定义函数规则</p>
<p>例子可以在上文看到，接下来来说明多级排序</p>
<p>多级排序，顾名思义，可以按照多个规则排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = (</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Emma&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Liam&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Olivia&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Noah&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Ava&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">21</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a ,key=<span class="keyword">lambda</span> x:(x[<span class="string">&quot;name&quot;</span>],x[<span class="string">&quot;age&quot;</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[&#123;&#x27;name&#x27;: &#x27;Ava&#x27;, &#x27;age&#x27;: 21&#125;, &#123;&#x27;name&#x27;: &#x27;Emma&#x27;, &#x27;age&#x27;: 20&#125;, &#123;&#x27;name&#x27;: &#x27;Liam&#x27;, &#x27;age&#x27;: 22&#125;, &#123;&#x27;name&#x27;: &#x27;Noah&#x27;, &#x27;age&#x27;: 24&#125;, &#123;&#x27;name&#x27;: &#x27;Olivia&#x27;, &#x27;age&#x27;: 19&#125;]</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，排序的规则是先以名字首字母为排序标准，而后以年龄为排序标准</p>
<p>若需要翻转排序，直接使用<code>reverse</code>会导致全部翻转，当需要指定一部分翻转的时候，可以如下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = ([<span class="number">1</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">7</span>], [<span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a, key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[[1, 9], [1, 6], [2, 7], [2, 5], [5, 9]]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里排序的结果是第一个元素按正序排列，而第二个元素按倒序的顺序排列</p>
<p>排列规则还可以用出现的次数来排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">a = [<span class="string">&quot;air&quot;</span>,<span class="string">&quot;air&quot;</span>,<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;ant&quot;</span>, <span class="string">&quot;banana&quot;</span>,<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;bus&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;car&quot;</span>, <span class="string">&quot;cake&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a, key=<span class="keyword">lambda</span> x: (-Counter(a)[x],x)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[&#x27;book&#x27;, &#x27;book&#x27;, &#x27;book&#x27;, &#x27;air&#x27;, &#x27;air&#x27;, &#x27;ant&#x27;, &#x27;ant&#x27;, &#x27;banana&#x27;, &#x27;banana&#x27;, &#x27;bus&#x27;, &#x27;cake&#x27;, &#x27;car&#x27;, &#x27;cat&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这里用了<code>Counter()</code>来统计出现的频率，后面你的排序标准先按频率排序，如果频率相同就按出现的字母顺序排序</p>
<hr>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>使用<code>sorted()</code>排序的时候，要注意排序的对象不可以混合（例如数字列表里面带了字符串）、</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的报错原因是<strong>无法将字符串和整数类型比较</strong></p>
<p>另外，<code>sorted()</code>排序字母的时候默认以大写字母优先：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;ant&quot;</span>,<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;Bunny&quot;</span>,<span class="string">&quot;Cherry&quot;</span>,<span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[&#x27;Apple&#x27;, &#x27;Book&#x27;, &#x27;Bunny&#x27;, &#x27;Cherry&#x27;, &#x27;ant&#x27;, &#x27;apple&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，下面输出的结果是优先排列大写字母</p>
<p>那要怎么解决这个情况呢，很简单，排序的时候，在规则<code>key</code>填入将字符串全部转换为小写（.lower()）即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;ant&quot;</span>,<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;Bunny&quot;</span>,<span class="string">&quot;Cherry&quot;</span>,<span class="string">&quot;apple&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a,key=<span class="keyword">lambda</span> x:x.lower()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[&#x27;ant&#x27;, &#x27;Apple&#x27;, &#x27;apple&#x27;, &#x27;Book&#x27;, &#x27;Bunny&#x27;, &#x27;Cherry&#x27;]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="max-min"><a href="#max-min" class="headerlink" title="max &amp; min"></a>max &amp; min</h4><p><code>max()</code>和<code>min()</code>语句关联性极高，使用方法完全一样，但是输出的结果相反，一个输出最大值，一个输出最小值</p>
<p>具体语法如下：<code>max(iterable, *[, key, default])</code></p>
<p>照例依次解读：</p>
<p><code>iterable</code>需要比较的值</p>
<p>后面的<code>*</code>同理，需要用关键词传递</p>
<p><code>key</code>代表比较的标准</p>
<p><code>default</code>指的是默认值，如果不填的话，传入的值如果是一个空值，则会导致报错，若填入，并且默认值有填，则返回的值为默认值，不会报错</p>
<p>由于这两者使用的方法一致，所以这里只展示一种</p>
<p>接下来来给出例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">72</span>,<span class="number">64</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">32</span>,<span class="number">56</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">23</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：72</span></span><br></pre></td></tr></table></figure>
<p>上面是一个最基本的例子，直接遍历找出最大值</p>
<p>接下来给出另一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;jump&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;flower&quot;</span>, <span class="string">&quot;eat&quot;</span>, <span class="string">&quot;slow&quot;</span>, <span class="string">&quot;star&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：slow</span></span><br></pre></td></tr></table></figure>
<p>这里的输出结果为<code>slow</code>的原因是：使用<code>key</code>的时候检测的是第一个字母中字典序最大的字符，也就是<code>s</code>，所以返回的也是<code>slow</code></p>
<p>除此之外，<code>max</code>比较的对象还可以是元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">7</span>),(<span class="number">3</span>,<span class="number">9</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：(5, 7)</span></span><br></pre></td></tr></table></figure>
<p>这里先比较元组内的第一个值，得出结果是<code>5</code>，而随后会在第一个值为5的元组中比较第二个值，得出结果为<code>7</code></p>
<p>因此结果为(5, 7)</p>
<p>接下来展示默认值的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a,default=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：0</span></span><br></pre></td></tr></table></figure>
<p>此处如果没有写默认值则会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：max() iterable argument is empty</span></span><br></pre></td></tr></table></figure>

<h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><p><code>max()</code>和<code>min()</code>的注意事项与<code>sorted</code>大同小异，可以直接参照<code>sorted()</code>的内容</p>
<hr>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p><code>zip()</code>同样是Python中的一个内置高阶函数，其用法如下：<code>zip(*iterables)</code></p>
<p>接下来照例来说明其具体的使用方法</p>
<p><code>zip()</code>的参数很简单，只有一个<code>*iterables</code>，这时候就有人要说了，诶，这里有星号，所以后面得用<code>iterables=</code>来传递参数</p>
<p>但其实并不是这样的，只有单独将<code>*</code>列出来（例如<code>sorted(iterable, *, key=None, reverse=False)</code>）才说明后面的参数需要用到关键字参数</p>
<p>这里的星号作用为 <strong>“位置参数收集符”</strong>，它的作用是将调用时传入的多个位置参数并将其打包成一个元组</p>
<p>接下来来举个例子说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">&quot;Zoe&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Lily&quot;</span>]</span><br><span class="line">age = [<span class="number">19</span>, <span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(name, age)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[(&#x27;Zoe&#x27;, 19), (&#x27;Jack&#x27;, 21), (&#x27;Lily&#x27;, 22)]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的每个列表里面的参数都被收集起来并打包成一个元组</p>
<p>使用<code>zip()</code>打包元组的时候，若打包的数据存在多余，则会自动舍弃：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">&quot;Zoe&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Aliya&quot;</span>]</span><br><span class="line">age = [<span class="number">19</span>, <span class="number">21</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(name, age)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[(&#x27;Zoe&#x27;, 19), (&#x27;Jack&#x27;, 21), (&#x27;Lily&#x27;, 22)]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的结果还是与上面一样，因为这里<code>age</code>只有三个值，所以自动舍弃掉<code>name</code>多出的值</p>
<p>此外，<code>zip()</code>还可以用于解压数据，接下来给出例子说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line">price = [<span class="number">12</span>, <span class="number">3</span>, <span class="number">28</span>]</span><br><span class="line">tuple_1 = <span class="built_in">list</span>(<span class="built_in">zip</span>(a,price))</span><br><span class="line"><span class="built_in">print</span>(tuple_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压数据</span></span><br><span class="line">item_1 ,price_1 = <span class="built_in">zip</span>(*tuple_1)</span><br><span class="line"><span class="built_in">print</span>(item_1,price_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[(&#x27;apple&#x27;, 12), (&#x27;banana&#x27;, 3), (&#x27;cherry&#x27;, 28)]</span></span><br><span class="line"><span class="comment"># (&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;) (12, 3, 28)</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，先用了<code>zip()</code>打包数据并转换成列表为变量<code>tuple_1</code>，之后再使用<code>zip(*tuple_1)</code>对<code>tuple_1</code>的数据进行解包，<code>item_1</code>和<code>tuple_1</code>分别是接受元素的变量</p>
<p>此外，在循环中，还可以用<code>zip()</code>来遍历多个可迭代的对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = [<span class="string">&quot;Alice&quot;</span>,<span class="string">&quot;Ethan&quot;</span>, <span class="string">&quot;Chloe&quot;</span>]</span><br><span class="line">d = [<span class="string">&quot;2025-07-23&quot;</span>,<span class="string">&quot;2025-07-25&quot;</span>,<span class="string">&quot;2025-07-27&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pe,da <span class="keyword">in</span> <span class="built_in">zip</span>(p,d):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;打卡记录：员工<span class="subst">&#123;pe&#125;</span>在<span class="subst">&#123;da&#125;</span>成功打卡！&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出：打卡记录：员工Alice在2025-07-23成功打卡！</span></span><br><span class="line"><span class="comment"># 打卡记录：员工Ethan在2025-07-25成功打卡！</span></span><br><span class="line"><span class="comment"># 打卡记录：员工Chloe在2025-07-27成功打卡！</span></span><br></pre></td></tr></table></figure>
<p>这里的原理是，每次for循环都会让变量<code>pe</code>和<code>da</code>分别接收<code>zip()</code>里的数据</p>
<p>而后循环内依次对数据进行引用，引用结束后重新接收数据</p>
<p><code>zip()</code>还可以将两个列表合并成一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">th = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line">td = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;20&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">zip</span>(th, td)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: &#x27;20&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里输出的结果是一个字典，而这个字典的键就是传入的第一个列表，而对应的值就是第二个传入的列表</p>
<h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果使用<code>zip()</code>遍历的对象是一个字典，此时返回的结果为这个字典的键，而不是值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Alice&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Aliya&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(a,b)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[(&#x27;name&#x27;, &#x27;name&#x27;), (&#x27;age&#x27;, &#x27;age&#x27;)]</span></span><br></pre></td></tr></table></figure>
<p>若想要返回的结果为对应的值，则需要在对应的对象后面加上<code>.values()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Alice&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Aliya&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(a.values(),b.values())))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[(&#x27;Alice&#x27;, &#x27;Aliya&#x27;), (23, 19)]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的结果就为对应的值了</p>
<hr>
<h4 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h4><p><code>reversed()</code>的作用是返回一个反向的迭代器，说白了就是把传入的东西反向输出</p>
<p>具体的语法如下：<code>reversed(seq)</code></p>
<p>这里<code>seq</code>指的是序列，包括<strong>列表、元组、字符串、range对象等</strong></p>
<p>也就是说<strong>字典是不可以的</strong></p>
<p>接下来给出例子说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(a)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[7, 1, 3, 1, 7, 4, 4, 2, 1, 2, 6, 5, 4, 1]</span></span><br></pre></td></tr></table></figure>

<p>在给出基础的例子后，接下来分别讲一下各个序列使用后的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a_l = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">32</span>,<span class="number">89</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">35</span>]</span><br><span class="line">a_t = (<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>)</span><br><span class="line">a_s = <span class="string">&quot;HelloWorld！&quot;</span></span><br><span class="line">a_r = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;初始序列：<span class="subst">&#123;a_l&#125;</span>\n<span class="subst">&#123;a_t&#125;</span>\n<span class="subst">&#123;a_s&#125;</span>\n<span class="subst">&#123;a_r&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">r_l = <span class="built_in">list</span>(<span class="built_in">reversed</span>(a_l))</span><br><span class="line">r_t = <span class="built_in">tuple</span>(<span class="built_in">reversed</span>(a_t))</span><br><span class="line">r_s = <span class="string">&quot;&quot;</span>.join(<span class="built_in">reversed</span>(a_s))</span><br><span class="line">r_r = <span class="built_in">list</span>(<span class="built_in">reversed</span>(a_r))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n反转序列：<span class="subst">&#123;r_l&#125;</span>\n<span class="subst">&#123;r_t&#125;</span>\n<span class="subst">&#123;r_s&#125;</span>\n<span class="subst">&#123;r_r&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：初始序列：[1, 4, 7, 32, 89, 3, 6, 2, 4, 35]</span></span><br><span class="line"><span class="comment"># (1, 3, 8, 5, 12, 3, 4, 6, 8)</span></span><br><span class="line"><span class="comment"># HelloWorld！</span></span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 反转序列：[35, 4, 2, 6, 3, 89, 32, 7, 4, 1]</span></span><br><span class="line"><span class="comment"># (8, 6, 4, 3, 12, 5, 8, 3, 1)</span></span><br><span class="line"><span class="comment"># ！dlroWolleH</span></span><br><span class="line"><span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<h5 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h5><p>如果需要反转不是序列的值，可以先转换成列表后再对其反转：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(d.values())))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[3, 2, 1]</span></span><br></pre></td></tr></table></figure>


<h2 id="匿名函数-Lambda"><a href="#匿名函数-Lambda" class="headerlink" title="匿名函数 Lambda"></a>匿名函数 Lambda</h2><p>Lambda的作用是创建一个一次性的简单函数，支持传入参数等操作</p>
<p>与普通的函数相比，匿名函数不需要<code>def</code>语句，并且即写即用。如果需要用到一些一次性的语句，便可以使用Lambda语句</p>
<p>接下来来详细介绍Lambda</p>
<h3 id="语法与使用场景"><a href="#语法与使用场景" class="headerlink" title="语法与使用场景"></a>语法与使用场景</h3><p>Lambda的语法非常简单，主要由下面三部分组成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y : x * y</span><br></pre></td></tr></table></figure>
<p>这里的<code>lambda</code>是告诉Python说下面的内容是有关匿名函数的内容，而后面的<code>x, y</code>就是这个匿名函数的位置参数，而后面的<code>x * y</code>就是匿名函数的表达式</p>
<p>下面给出一个实际例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multiply = <span class="keyword">lambda</span> x, y : x * y</span><br><span class="line"><span class="built_in">print</span>(multiply(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：2</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了一个匿名函数，并通过变量<code>multiply</code>引用它</p>
<p>当然，如果你不想用变量引用，也可以用下面这种形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> x, y: x * y)(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>这样的话代码会比较简洁，但缺点是不能通过变量调用</p>
<p>使用Lambda的场景大部分是在需要使用一些简单的一次性操作中，这类场景由于语句比较简单，所以不需要使用具名函数<code>def</code>来定义函数，故使用匿名函数</p>
<h3 id="与常规函数对比"><a href="#与常规函数对比" class="headerlink" title="与常规函数对比"></a>与常规函数对比</h3><p>匿名函数与具名函数的对比很明显，接下来列个表格来说明</p>
<table>
    <thead>
        <tr>
            <th>特性</th>
            <th>匿名函数lambda</th>
            <th>具名函数def</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>定义方式</td>
            <td>使用<strong>Lambda</strong>关键字</td>
            <td>使用<strong>def</strong>关键字</td>
        <tr>
        <tr>
            <td>函数名称</td>
            <td>无函数名称（要不然为什么叫匿名函数），但仍可以用变量引用</td>
            <td>必须有名称，否则无法调用</td>
        <tr>
        <tr>
            <td>函数主体</td>
            <td>只能有一条表达式</td>
            <td>可以用多个表达式，甚至可以有其他函数</td>
        <tr>
        <tr>
            <td>返回结果</td>
            <td>自动返回</td>
            <td>用return语句，忘记加自动识别为return None</td>
        <tr>
        <tr>
            <td>适合场景</td>
            <td>简单的语句</td>
            <td>需要复杂运算（表达式多于一行）</td>
        <tr>
    </tbody>
</table>

<p>可以看到，匿名函数与具名函数各有各的特点</p>
<p>接下来用一个具体的例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, a2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;传入的值为<span class="subst">&#123;a1&#125;</span>和<span class="subst">&#123;a2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a1 ** a2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;相加的值为：&quot;</span>,(<span class="keyword">lambda</span> x, y:x + y)(a_func(<span class="number">10</span>,<span class="number">2</span>),<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：传入的值为10和2</span></span><br><span class="line"><span class="comment"># 相加的值为： 103</span></span><br></pre></td></tr></table></figure>
<p>可以看到在这个例子中，有多个语句的使用了具名函数，而简单计算使用了匿名函数</p>
<hr>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器是Python中一个强大的语法糖，其作用是在不改变函数原有结构的前提下，给函数添加新的功能</p>
<p>其基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># body</span></span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m_func</span>():</span><br><span class="line">    <span class="comment"># body</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">m_func()</span><br></pre></td></tr></table></figure>

<p>给出基本结构后，接下来给出例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">s_func</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在装饰器执行之前&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;在装饰器执行之后&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> s_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行装饰器&quot;</span>)</span><br><span class="line"></span><br><span class="line">m_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：在装饰器执行之前</span></span><br><span class="line"><span class="comment"># 正在执行装饰器</span></span><br><span class="line"><span class="comment"># 在装饰器执行之后</span></span><br></pre></td></tr></table></figure>

<p>接下来来逐一讲解一下：</p>
<p>首先，一开始函数定义的时候，便会自动执行以下步骤</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_func = a_func(m_func)</span><br></pre></td></tr></table></figure>

<p>此时<code>m_func</code>就相当于<code>a_func()</code>返回的值，也就是<code>s_func()</code>，后面调用<code>m_func()</code>实际上是调用<code>s_func()</code></p>
<p>接下来就是正常执行了，也就是执行<code>m_func()</code>，但实际上是<code>s_func()</code></p>
<p>这里可能就有人要问了，诶，那我看<code>s_func()</code>里面有个外部参数<code>func()</code>啊，怎么没有传来呢？</p>
<p>其实这里一开始就传进来了，我们可以看到这里，还记得一开始<code>m_func</code>是怎么变成<code>s_func</code>的吗？没错！<code>m_func = a_func(m_func)</code>，这里其实已经传进值了，并且由于内部函数<code>s_func()</code>是个闭包，这里的参数没有因为<code>return</code>而被销毁</p>
<h3 id="常见的装饰器"><a href="#常见的装饰器" class="headerlink" title="常见的装饰器"></a>常见的装饰器</h3><p>接下来来讲讲Python中常见的装饰器，主要有<code>计时器</code>、<code>日志</code>、<code>权限验证</code></p>
<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>首先来讲讲计时器，计时器是装饰器的一个常见的用途，用于记录函数运行的时间，下面给出一个例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数<span class="subst">&#123;func.__name__&#125;</span>的执行时间为：<span class="subst">&#123;end_time - start_time:<span class="number">.4</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> check</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">a, b</span>):</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test1(<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：函数test1的执行时间为：0.5001s</span></span><br><span class="line"><span class="comment"># 8</span></span><br></pre></td></tr></table></figure>
<p>接下来来逐一介绍其功能</p>
<p>首先是照例，函数一开始的<strong>定义阶段</strong>，当执行<code>@timer</code>时（一开始的时候），<code>test1(3,5)</code>转换为<code>check()</code>，顺带把两个参数丢进去闭包里面，之后开始执行<code>check()</code>，所以此时执行的实际上是<code>check(3,5)</code></p>
<p><code>check()</code>一开始先记录时间（<code>start_time</code>），之后开始执行函数<code>func()</code>（这里也就是<code>test1()</code>）在执行后便再次记录时间（<code>end_time</code>），这里两次计时是为了算出总执行时间</p>
<p>最后打印结果：<code>func.__name__</code>为执行的函数的名字，后面的两个时间相减便是函数执行总耗时，<code>:.4f</code>则为精确到小数点后4位（不取小数点结果则为：0.5001778602600098s）</p>
<p>这里需要另外补充的一点是<code>check(*args, **kwargs)</code>中<code>*args, **kwargs</code>的目的是为了传入所有的值，包括位置参数和关键字参数，这样就可以有效地避免了有参数没传进去，后面的<code>func(*args,**kwargs)</code>则是把传进的数据重新解包出来，然后再传进原函数<code>func()</code></p>
<p>而一开始的<code>@functools.wraps(func)</code>是为了保存原函数的元数据，也就是<code>test1()</code>的元数据，这里如果不这样做的话，那么使用<code>print(test1.__name__)</code>的结果为<code>check()</code>而不是原先的<code>test1()</code></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>通过使用装饰器还可以实现日志的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        logging.info(<span class="string">f&quot;调用函数<span class="subst">&#123;func.__name__&#125;</span>，参数：args = <span class="subst">&#123;args&#125;</span>和 kwargs = <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        logging.info(<span class="string">f&quot;函数返回值：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a1, b1</span>):</span><br><span class="line">    <span class="keyword">if</span> a1 &gt; b1:</span><br><span class="line">        <span class="keyword">return</span> a1 + b1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a1 * b1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_1 = [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> list_1:</span><br><span class="line">    a_func(a, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：2025-07-29 16:12:43,548 - INFO - 调用函数a_func，参数：args = (1, 3)和 kwargs = &#123;&#125;</span></span><br><span class="line"><span class="comment"># 2025-07-29 16:12:43,548 - INFO - 函数返回值：3</span></span><br><span class="line"><span class="comment"># 2025-07-29 16:12:43,548 - INFO - 调用函数a_func，参数：args = (2, 6)和 kwargs = &#123;&#125;</span></span><br><span class="line"><span class="comment"># 2025-07-29 16:12:43,548 - INFO - 函数返回值：12</span></span><br></pre></td></tr></table></figure>

<p>接下来来逐一讲解</p>
<p>首先先讲讲<code>logging.basicConfig()</code></p>
<p><code>level=logging.INFO</code>的作用的只让INFO及以上级别的日志能被输出，级别如下：<code>DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</code></p>
<p>接下来是<code>format=&#39;%(asctime)s - %(levelname)s - %(message)s&#39;</code></p>
<p>这个指的是输出时的默认格式，分别是<strong>时间</strong>，<strong>名称</strong>，<strong>具体内容</strong></p>
<p>首先还是老样子，在函数定义的时候，<code>a_func(a, b)</code>将参数传给<code>log(func)</code>，并且<code>a_func()</code>变为<code>wrapper()</code></p>
<p>之后开始运行的时候，调用<code>wrapper()</code>，<code>*args</code>和<code>**kwargs</code>一开始定义的时候就被传进去了</p>
<p>接下来来说说<code>wrapper()</code>里面的内容</p>
<p><code>logging.info</code>，的作用是输出一条<code>INFO</code>级别的信息</p>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>接下来讲讲带参数的装饰器</p>
<p>带参数的装饰器也叫做<strong>装饰器工厂</strong>，作用是通过传递参数来自定义装饰器的行为</p>
<p>接下来来用一个例子来实际说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">precision=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;参数：args =<span class="subst">&#123;args&#125;</span>，kwargs = <span class="subst">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class="line">            start_time = time.perf_counter()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            end_time = time.perf_counter()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;函数<span class="subst">&#123;func.__name__&#125;</span>，运行时间：<span class="subst">&#123;end_time - start_time:.&#123;precision&#125;</span>f&#125;s&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">precision=<span class="number">6</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_6</span>(<span class="params">n</span>):</span><br><span class="line">    a = [i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> n]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">precision=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_4</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> (a + b) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_4(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">add_6(l)</span><br></pre></td></tr></table></figure>

<p>可以看到，这里有两个装饰器，并且装饰器带有参数</p>
<p>接下来来简单讲解一下，因为带了参数的装饰器本质上就比普通装饰器多了一层传进参数</p>
<p>首先第一步定义函数阶段：在定义的时候（也就是<code>@timer(precision=3)</code>的时候），会调用<code>timer(precision=3)</code>把参数传进去，之后返回函数<code>decorate()</code></p>
<p>接下来返回之后，<code>decorate()</code>会接收原函数<code>add_4()</code>，同时将<code>add_4()</code>替换为<code>decorate(add_4)</code>的返回值，也就是<code>wrapper()</code>。其实这一部分是跟一般的装饰器是一样的</p>
<p>之后运行的时候，调用<code>add_4(10, 2)</code>实际上相当于<code>wrapper(10, 2)</code></p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>接下来来讲讲类装饰器。类装饰器的核心是通过实现 <code>__call__</code> 方法，让类的实例可以像函数一样被调用，从而实现装饰逻辑。由于类可以通过<code>__init__</code>的初始化状态来记住一些值，所以可以用在一些场景里面，比如说计数</p>
<p>首先给出一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        result = <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;计算结果为：<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;运行次数为：<span class="subst">&#123;self.count&#125;</span>次&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@Add</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = [(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">9</span>,<span class="number">4</span>),(<span class="number">8</span>,<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    add_1(i[<span class="number">0</span>],i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：计算结果为：4</span></span><br><span class="line"><span class="comment"># 运行次数为：1次</span></span><br><span class="line"><span class="comment"># 计算结果为：13</span></span><br><span class="line"><span class="comment"># 运行次数为：2次</span></span><br><span class="line"><span class="comment"># 计算结果为：13</span></span><br><span class="line"><span class="comment"># 运行次数为：3次</span></span><br></pre></td></tr></table></figure>
<p>首先我们从<code>__init__</code>看起，这里<code>__init__</code>把被装饰的函数对象绑给<code>self.func</code>，其实也就是<code>add_1</code>，之后的<code>self.count = 0</code>则是计数的次数，用于后面的计数</p>
<p>接下来看到<code>__call__</code>，这里先接收传进来的值<code>*args, **kwargs</code>，也就是被装饰函数调用时传入的参数</p>
<p>这里对应的是<code>add_1(i[0],i[1])</code>中的<code>i[0],i[1]</code>，这里需要强调的，不要看到有两个就想当然的认为<code>*args</code>和<code>**kwargs</code>一人负责一个，这里全由<code>*args</code>负责，因为都是位置参数，不是<strong>关键字参数</strong></p>
<p>接下来看到函数的内部，首先第一行是<code>self.count += 1</code>，也就是将运行次数加一</p>
<p>下一行的<code>result</code>是将原函数的运行结果绑定到这个变量上，对应的内容就是<code>return a + b</code>里面的<code>a + b</code></p>
<p>而后面的两行就是基础的输出内容，这里不多赘述</p>
<p>这里的话装饰器还是一样，在一开始定义的时候自动执行<code>add_1 = Add(add_1)</code>，<code>add_1</code>被替换为<code>Add类</code>的实例</p>
<p>接下来是<strong>装饰器工厂类</strong>，这个的原理跟上文<strong>带参数的装饰器</strong>差不多，这里不多赘述</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>接下来来讲讲生成器。生成器的作用是逐步生成一个值，通过<code>yield</code>返回值，并暂时停止，利用<code>next()</code>重新激活生成器</p>
<p>接下来通过一个例子来说明生成器的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">n</span>):</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= n:</span><br><span class="line">        <span class="keyword">yield</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">count_1 = a_func(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(count_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(count_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(count_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(count_1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(count_1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<p>首先一开始先看到这一行：<code>count_1 = a_func(5)</code>这里可以看到，是将一个值（<code>5</code>）传入函数<code>a_func()</code>，但此时函数并未执行，只是创建了一个生成器对象</p>
<p>之后开始执行<code>next(count_1)</code>，也就开始运行函数，这里一开始<code>count</code>为<code>1</code>，满足循环<code>count &lt;= n</code>的条件，所以执行循环内的操作，也就是产出<code>count</code>的值，同时将生成器定格在这里</p>
<p>接下来来到第二个<code>next(count_1)</code>，由于这里有<code>next()</code>所以刚才在第一步定格的生成器开始执行，也就是运行<code>yield</code>的下一步：<code>count += 1</code></p>
<p>在执行后重新循环，由于新的<code>count</code>满足循环条件，所以继续进入循环，还是返回<code>count</code>的值并定格</p>
<p>接下来的三、四、五的道理跟二一样</p>
<p>这时候就有人要说了，诶，既然一开始传入的值是5，那么如果执行第六步会发生什么事情呢</p>
<p>如果选择执行第六次的话，则会报错：<code>StopIteration</code></p>
<p>这是由于已经跳出循环，生成器无法找到<code>yield</code>来返回值导致的</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>接下来来讲讲生成器表达式。生成器表达式可以与列表推导式相类比：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> l] <span class="comment"># 列表推导式</span></span><br><span class="line">c = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> l) <span class="comment"># 生成器表达式</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里列表推导式和生成器表达式的在表达式上的区别就是包裹的括号的区别</p>
<p>接下来来通过实例来说明两者之间的不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">a = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> l)</span><br><span class="line">b = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> l]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[1, 4, 9]</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里两个有着巨大的差距</p>
<p>使用列表推导式只需要一次就可以将整个列表输出出来</p>
<p>而生成器表达式则需要逐步才能输出出来</p>
<p>这也是生成器（作为一种迭代器）的一个特点：<strong>惰性输出</strong>(用的时候才输出)</p>
<p>这有什么好处呢？假设你有一个无限列表，如果用列表推导式输出，由于列表推导式需要将整个列表一次性全部输出出来，但是这个列表是无限长的，这就导致了<strong>永远也无法输出</strong></p>
<p>而生成器表达式因其惰性输出的特点，可以选择性的输出值，在这个场景下就可以正常输出</p>
<p>这里还要补充的一点是，如果选择直接输出生成器（也就是不加（next()）返回的对象是一个生成器对象，长这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at 内存地址&gt;</span><br></pre></td></tr></table></figure>

<p>这也是为什么要用<code>next()</code>输出值的原因</p>
<p>如果觉得使用<code>next()</code>不够方便，可以选择<code>for循环</code>来输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">a = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p>这样的好处是一旦结束会自动停止生成，不会抛出<code>StopIteration</code></p>
<p>诶，为什么可以这样呢？那是因为<code>for循环</code>自动帮我们完成了<code>next()</code>迭代和<code>StopIteration</code>异常处理，并且当遇到<code>StopIteration</code>的时候自动结束，所以不需要我们自行执行<code>next()</code></p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数是指在函数内部直接或间接调用自身的函数。</p>
<p>简单来说就是在这个函数内部可以自己调用自己，从而实现循环的一种函数</p>
<p>接下来举个例子来说明一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">m</span>):</span><br><span class="line">    c = m ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">b_func</span>(<span class="params">n,target</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt; target :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;当前参数的值为：<span class="subst">&#123;n&#125;</span>，还没有达到目标值：<span class="subst">&#123;target&#125;</span>，继续递归！&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> b_func(n + <span class="number">1</span>,target)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前参数的值为：<span class="subst">&#123;n&#125;</span>，已经达到目标值啦，结束递归！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> b_func(m,c)</span><br><span class="line"></span><br><span class="line">a_func(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>接下来解释一下：</p>
<p>首先先从函数<code>a_func()</code>讲起。这里是定义了一个变量<code>c</code>作为最大值，之后返回内部函数<code>b_func()</code>，也就是执行主要的部分</p>
<p>接下来讲讲内部函数<code>b_func()</code>，可以看到这里定义了两个位置参数，分别是<code>n</code>，也就是传进来的数字（这里为<code>2</code>，来自这里<code>a_func(2)</code>），还有另一个位置参数<code>target</code>，也就是之前的变量<code>c</code>，这里的作用是作为一个边界</p>
<p>首先一开始判断是否超过边界，如果没有，则继续执行，其中的重点是<code>return</code>语句，这里可以发现返回的是这个函数，也就是<code>b_func()</code>这里也就是<strong>递归函数</strong>的体现</p>
<p>之后便一次一次的执行判断，直到跳出不满足结果（也就是达到边界<code>target</code>）</p>
<h3 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h3><p>接下来讲讲尾递归优化，递归分为两种：<strong>普通递归</strong> 和 <strong>尾递归</strong></p>
<p>首先是普通递归，普通递归指的是在调用后还得处理其他操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">n</span>):</span><br><span class="line">    num = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num * a_func(n)</span><br></pre></td></tr></table></figure>
<p>上面就是一个普通递归的例子，在这里例子中，递归函数时还需要执行其他操作，也就是<code>num * a_func(n)</code></p>
<p>而尾递归是指除了递归函数外没有其他的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a,b = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a_func(b, a + b)</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的最后一步为调用自己，没有其他的操作</p>
<p>那为什么要尾递归优化呢？递归最大的问题是，每次在调用递归时都会在内存中创建一个叫<strong>栈帧</strong>的东西，这个东西是用来存储一些保存在函数中的局部变量等信息</p>
<p>而如果递归的次数过多，则会导致栈帧堆积，造成<strong>栈溢出</strong></p>
<p>而尾递归优化能识别出尾递归形式，在递归调用时复用当前栈帧（而不是创建新栈帧）。这样无论递归多少次，栈帧数量都保持不变，从根本上避免了栈溢出。</p>
<p>但很可惜的是<strong>Python并不支持尾递归优化</strong>，但可以用其他方法来替代，比如循环或手动模拟栈</p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>接下来来讲讲函数式编程，强调将计算视为函数的组合，与一般的命令式编程（强调怎么做）不同，函数式编程强调做什么</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数是函数式编程的核心所在，其满足两个条件：<strong>输出仅由输入决定（也称为确定性）<strong>和</strong>无副作用</strong></p>
<p>接下来来分别介绍这两个条件是什么</p>
<p>输出仅由输入决定（确定性）：也就是说如果输入相同，则<strong>输出一定相同</strong></p>
<p>无副作用：也就是说不修改函数外部的状态（比如说全局变量）</p>
<p>具体讲讲什么是副作用</p>
<h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><p>接下来通过例子来说明什么是副作用：<br><strong>修改全局变量</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，全局变量<code>a</code>在函数中得到了修改，也就是其副作用的体现</p>
<p><strong>修改传入的可变参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    l.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，副作用体现在可变参数列表新元素的加入</p>
<p><strong>执行I&#x2F;O操作</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，副作用体现在用<code>print</code>打印变量</p>
<p><strong>输入相同，输出不同</strong></p>
<p>这类情况常见发生在有随机数的函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a + random.randint(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>这里即使传入的参数<code>a</code>是相同的，但由于随机数的原因，输出的结果是不同的</p>
<p>纯函数的内部可以有局部变量、循环等逻辑，但一定要满足所有的变量都是局部的，以及对输入参数的处理是只读的</p>
<h3 id="不可变数据"><a href="#不可变数据" class="headerlink" title="不可变数据"></a>不可变数据</h3><p>不可变数据是函数式编程中的一个重点，其基本原理是数据一旦创建，就不能被修改。任何对数据的 “修改” 操作，实际上都会生成一个全新的数据副本，而原始数据始终保持不变</p>
<p>好处是可以避免很多的因为数据变更导致的问题，同时还可以增强可靠性</p>
<h4 id="常见的不可变数据类型"><a href="#常见的不可变数据类型" class="headerlink" title="常见的不可变数据类型"></a>常见的不可变数据类型</h4><table>
    <thead>
        <tr>
            <th>类型</th>
            <th>示例</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>整数</td>
            <td>a = 1</td>
        </tr>
        <tr>
            <td>浮点数</td>
            <td>a = 1.1</td>
        </tr>
        <tr>
            <td>字符串</td>
            <td>a = "这是一个字符串"</td>
        </tr>
        <tr>
            <td>元组</td>
            <td>a = (1,2,3)</td>
        </tr>
        <tr>
            <td>冻结集合</td>
            <td>a = frozenset([1,2])</td>
        </tr>
        <tr>
            <td>布尔值</td>
            <td>a = True</td>
        </tr>
    </tbody>
</table>

<h4 id="不可变性的“不可修改”"><a href="#不可变性的“不可修改”" class="headerlink" title="不可变性的“不可修改”"></a>不可变性的“不可修改”</h4><p>这里来讲讲<strong>不可修改</strong></p>
<p>在看完上文的不可变类型数据之后，这时候可能就有人有疑惑了，诶，那平时写的时候不是一个变量的值可以多次切换吗</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>确实，上面的例子中变量<code>a</code>从1切换到了2，但事实上这里是创建了一个新的数据，而不是在原有的基础上修改</p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>魔术方法是一类以__开头和结尾的方法，可以为Python对象定义特定的行为</p>
<p>这些魔术方法的核心特点是：一般情况下不需要手动调用，而是在特定的常见下由解释器自动触发</p>
<p>接下来给出例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, room</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.room = room</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> 同学你好，你的班级是<span class="subst">&#123;self.room&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cm_1 = Aclass(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;303&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cm_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：小明 同学你好，你的班级是303</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来来说明这个例子中的各个部分</p>
<p>基础的<code>__init__</code>作用是创建实例时自动调用，为实例绑定属性。括号内跟着的第一个是参数名，也就是这个实例本身，用来访问这个实例的属性</p>
<p>这里将两个属性分别指定为两个传进来的参数值</p>
<p>之后是另一个魔术方法，也就是<code>__str__</code></p>
<p>这个魔术方法的作用是，当定义的对象被<code>str()</code>或<code>print()</code>调用时输出的格式</p>
<p>从上面的例子的输出可以看到，内容正好是<code>__str__</code>内<code>return</code>后跟着的格式</p>
<p>魔术方法实现了高度的自定义，可以用这个方法实现诸多的内容</p>
<p>当然，Python中的魔术方法还有很多，接下来列出一些常用的</p>
<p>[TODO]</p>
<h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>接下来来讲讲上下文管理器，也就是<code>__enter__</code>和<code>__exit__</code></p>
<p>其中<code>__enter__</code>的作用是 进入<code>with</code>代码块的时候自动调用，并且返回的对象会被<code>as</code>吸收</p>
<p>而<code>__exit__</code>则是在退出<code>with</code>代码块的时候自动调用，即使是发生异常也照样调用，主要用于关闭文件、释放资源等操作</p>
<p>接下来举个例子来说明实际用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.start_time = time.time()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="variable language_">self</span>.end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;运行时间：<span class="subst">&#123;self.end_time - self.start_time:<span class="number">.4</span>f&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timer() <span class="keyword">as</span> t:</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来来逐一讲解。首先是<code>with语句</code>，执行的时候便触发<code>__enter__</code>开始计时，之后执行其内部的内容，也就是<code>time.sleep(0.5)</code></p>
<p>在执行后，<code>with语句</code>结束，执行<code>__exit__</code>，结束计时，并且输出运行时间</p>
<hr>
<h2 id="调试与测试"><a href="#调试与测试" class="headerlink" title="调试与测试"></a>调试与测试</h2><h3 id="函数文档字符串"><a href="#函数文档字符串" class="headerlink" title="函数文档字符串"></a>函数文档字符串</h3><p>接下来来讲讲函数文档字符串，这个字符串是一个特殊的字符串，用于注明函数内的内容，也就是解释函数中的功能，参数等关键信息</p>
<p>函数文档字符串有多种风格，比如说：<code>Google 风格</code>，<code>NumPy/SciPy 风格</code>和<code>reStructuredText 风格</code></p>
<p>由于Pycharm会默认使用<code>reStructuredText 风格</code>，所以这里将使用这个风格来说明</p>
<p>接下来通过一个例子来说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pell_list</span>(<span class="params">a, b, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param a: 数列的第一项</span></span><br><span class="line"><span class="string">    :type a: int</span></span><br><span class="line"><span class="string">    :param b: 数列的第二项</span></span><br><span class="line"><span class="string">    :type b: int</span></span><br><span class="line"><span class="string">    :param n: 数列的总项数</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :return: 一个包含 n 项的佩尔数列</span></span><br><span class="line"><span class="string">    :rtype:list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">j, k, c, seq</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param j: 数列的第一项</span></span><br><span class="line"><span class="string">        :type j: int</span></span><br><span class="line"><span class="string">        :param k: 数列的第二项</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :param c: 一开始的次数</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :param seq: 空白数列，用于存储生成项的列表</span></span><br><span class="line"><span class="string">        :type seq: list</span></span><br><span class="line"><span class="string">        :return: 一个完整的佩尔数列</span></span><br><span class="line"><span class="string">        :rtype: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> c == n:</span><br><span class="line">            <span class="keyword">return</span> seq</span><br><span class="line">        seq.append(j)</span><br><span class="line">        j, k = k, k * <span class="number">2</span> + j</span><br><span class="line">        c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> wrapper(j, k, c, seq)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper(a, b, <span class="number">0</span>, [])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pell_list(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>接下来来说明每个属性的内容：</p>
<p><code>:param + 变量名:</code>用于说明变量的作用</p>
<p><code>:type + 变量名:</code>用于说明变量的类型</p>
<p><code>:return + 变量名:</code>用于说明返回的作用</p>
<p><code>:rtype:</code>用于说明返回值的类型</p>
<p>需要注意的一点是，函数文档字符串可以通过<code>help()</code>访问，并且函数文档字符串会存储在<code>__doc__</code>里面</p>
<p>接下来展示另外两种风格：</p>
<p>首先是<code>Google 风格</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        a(int): 传入的数据，平方的底数</span></span><br><span class="line"><span class="string">        b(int): 平方计算的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: 平方计算的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    b = a ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">a_func(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>在<code>Google 风格</code>中，使用<code>Args:</code>标出变量的作用，使用<code>Returns:</code>标出返回值的作用，使用<code>Raises:</code>说明报错的触发条件</p>
<p>接下来是<code>NumPy/SciPy 风格</code>，这个风格的一大特点就是<strong>标准化</strong>，因为会使用到缩进和分割线来划分区域</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameter</span></span><br><span class="line"><span class="string">    ---------</span></span><br><span class="line"><span class="string">    a : int</span></span><br><span class="line"><span class="string">        传入的数据，平方的底数</span></span><br><span class="line"><span class="string">    b : int</span></span><br><span class="line"><span class="string">        平方计算的结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">        平方计算的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    b = a ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">a_func(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，在这种风格中，<code>Parameter</code>用来说明变量对应的作用，同时在下一行用分割线划分区域，而<code>Returns</code>则用来说明返回的结果</p>
<h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>类型注解是Python中一种注明数据类型的方式，目的是为了方便理解对应数据的类型从而增强代码的可读性</p>
<p>使用的方法也很简单，只需要在对应的变量后面加上<code>:</code>即可，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a : <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    b : <span class="built_in">int</span> = a ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">a_func(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，这里变量<code>a</code>和<code>b</code>后面都注明了相应的类型</p>
<p>可以观察到，在函数后面有一个小箭头指着<code>int</code>，这是说明返回的类型是<code>int</code></p>
<h3 id="单元测试基础"><a href="#单元测试基础" class="headerlink" title="单元测试基础"></a>单元测试基础</h3><p>接下来介绍单元测试基础，目的是测试代码能否正常工作，其核心为Python中的<code>unittest</code>库</p>
<p>在使用这个库的时候，我们会用到里面的这些东西：</p>
<p><code>TestCase 类</code>：用于定义一个测试的方法，测试的主要步骤存放在这个类里面</p>
<p><code>测试方法</code>：测试方法是一系列以<code>test_</code>开头的方法，相应的测试方式便存放在这里面</p>
<p>这里需要注意的是，测试方法的命名<strong>必须以test_开头</strong>，否则无法识别</p>
<p>这是因为<code>unittest</code>通过<code>TestLoader</code>类自动发现测试用例，其默认逻辑是：在继承<code>TestCase</code>的类中，只识别名称以<code>test_</code>开头的方法作为测试方法。</p>
<p>这样做的原因是为了使测试方法与一般的方法区分来开，如果全部都执行的话，可能会造成一些问题</p>
<p><code>断言方法</code>：断言方法的作用是验证实际的结果与预计的结果是否一致（相当于<code>if语句</code>判断）</p>
<p><code>测试套件</code>：测试套件的作用是让指定的测试文件批量执行，做到批量测试的效果，在大规模测试中可以一次性执行所有测试，不需要一次一次的执行测试文件</p>
<p>接下来举个例子来说明其使用方法</p>
<p>假设你有一个文件<code>math_add.py</code>，其代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候你想测试这个代码，于是你新建了一个测试文件<code>math_add_test.py</code></p>
<p>首先需要导入<code>unittest</code>这个库</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br></pre></td></tr></table></figure>

<p>同时又因为你需要测试的方法来自<code>math_add.py</code>里面，所以还需要导入这个文件的方法到这里面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math_add <span class="keyword">import</span> add</span><br></pre></td></tr></table></figure>

<p>在完成以上的导入步骤后，接下来就是写这个测试文件的核心内容了</p>
<p>首先是继承<code>unittest.TestCase</code>方法，先写一个类，之后在这里类的类名后面写上要继承的方法即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathAdd</span>(unittest.TestCase):</span><br></pre></td></tr></table></figure>

<p>接下来是写类里面的测试方法：</p>
<p>由于这里是为了验证加法的结果是否正确，我们需要用到的断言方法是<code>assertEqual(a, b)</code></p>
<p>这个断言方法的作用是判断<code>a</code>和<code>b</code>是否相等</p>
<p>这里由于<code>add</code>（要测试的方法）返回的结果就是两个参数之和，所以这里就直接填入即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>这里还可以多加几次验证，最后的结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">3</span>), <span class="number">4</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, -<span class="number">3</span>), -<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>那么要怎么运行测试呢？只需要在外部作用域加上<code>unittest.main()</code>即可开始测试</p>
<p>上文也提及到了，<code>unittest.main()</code>只会运行那些变量名为<code>test_</code>开头的方法</p>
<p>最后完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> math_add <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMathAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">3</span>), <span class="number">4</span>)</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, -<span class="number">3</span>), -<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行后输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="断言方法"><a href="#断言方法" class="headerlink" title="断言方法"></a>断言方法</h4><p>在介绍完基础的测试例子后，接下来来讲讲断言方法，上文例子中使用的为<code>self.assertEqual(a, b)</code>，此外还有很多</p>
<p>需要提示的一点是，下文方法中出现的<code>msg</code>对应的是验证不通过后的文本显示</p>
<table>
    <thead>
        <tr>
            <th>断言方法</th>
            <th>作用</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>assertEqual(a, b, msg=None)</td>
            <td>用于验证a == b（a等于b）</td>    
        </tr>
        <tr>
            <td>assertNotEqual(a, b, msg=None)</td>
            <td>用于验证a != b（a不等于b）</td>    
        </tr>
        <tr>
            <td>assertTrue(x, msg=None)</td>
            <td>用于验证x是否为<strong>True</strong></td>    
        </tr>
        <tr>
            <td>assertFalse(x, msg=None)</td>
            <td>用于验证x是否为<strong>False</strong></td>    
        </tr>
        <tr>
            <td>assertIs(a, b, msg=None)</td>
            <td>用于验证a和b是否为用一个对象（这里不是单单指两者的值相等，例如a = 1，b = 1是不同的对象）</td>    
        </tr>
        <tr>
            <td>assertIsNot(a, b, msg=None)	</td>
            <td>用于验证a和b是否为不同对象</td>    
        </tr>
        <tr>
            <td>assertIsNone(x, msg=None)</td>
            <td>用于验证x是否为空值</td>    
        </tr>
        <tr>
            <td>assertIsNotNone(x, msg=None)</td>
            <td>用于验证x是否不为空值</td>    
        </tr>
        <tr>
            <td>assertGreater(a, b, msg=None)</td>
            <td>用于验证a是否大于b（a > b）</td>    
        </tr>
        <tr>
            <td>assertGreaterEqual(a, b, msg=None)</td>
            <td>用于验证a是否大于等于b（a >= b）</td>    
        </tr>
        <tr>
            <td>assertLess(a, b, msg=None)</td>
            <td>用于验证a是否小于b（a < b）</td>    
        </tr>
        <tr>
            <td>assertLessEqual(a, b, msg=None)</td>
            <td>用于验证a是否小于等于b（a <= b）</td>    
        </tr>
        <tr>
            <td>assertIn(a, b, msg=None)</td>
            <td>用于验证a是否为b的元素（a in b）</td>    
        </tr>
        <tr>
            <td>assertNotIn(a, b, msg=None)</td>
            <td>用于验证a是否不为b的元素（a not in b）</td>    
        </tr>
        <tr>
            <td>assertSetEqual(a, b, msg=None)</td>
            <td>用于验证集合a和集合b是否相等</td>    
        </tr>
        <tr>
            <td>assertListEqual(a, b, msg=None)</td>
            <td>用于验证列表a与列表b是否相等（顺序相等）</td>    
        </tr>
        <tr>
            <td>assertDictEqual(a, b, msg=None)</td>
            <td>用于验证字典a和字典b是否相等</td>    
        </tr>
        <tr>
            <td>assertMultiLineEqual(a, b, msg=None)/td>
            <td>用于验证多行字符串是否相等，a和b都是多行的字符串</td>    
        </tr>
        <tr>
            <td>assertRegex(s, regex, msg=None)</td>
            <td>用于验证字符串s是否匹配正则表达式regex</td>    
        </tr>
        <tr>
            <td>assertNotRegex(s, regex, msg=None)</td>
            <td>用于验证字符串s是否不匹配正则表达式regex</td>    
        </tr>
        <tr>
            <td>assertAlmostEqual(a, b, places=7, msg=None)</td>
            <td>用于验证a和b的差是否在10^(-places)范围内，这里places默认为7（需要这个的原因是判断浮点数的时候assertEqual可能不准，例如0.1 + 0.2 实际为0.30000000000000004，这里如果用assertEqual是不通过验证的）</td>    
        </tr>
        <tr>
            <td>assertRaises(exception, callable, *args, **kwargs)</td>
            <td>用于验证调用callable(*args, **kwargs)的时候是否会出现exception的异常（举个例子：self.assertRaises(ValueError, int, "abc")，这里会报错ValueError，所以通过验证）</td>    
        </tr>
        <tr>
            <td>assertRaisesRegex(exception, regex, callable, *args, **kwargs)</td>
            <td>用于验证抛出的错误是否匹配正则表达式regex</td>    
        </tr>
        <tr>
            <td>assertIsInstance(a, b, msg=None)</td>
            <td>用于验证a是否为类型b</td>    
        </tr>
        <tr>
            <td>assertNotIsInstance(a, b, msg=None)</td>
            <td>用于验证a是否不为类型b</td>    
        </tr>
    </tbody>
</table>

<h4 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h4><p>测试套件是用来管理和组织多个测试用例（TestCase）的容器。可以组合测试用例，从而实现批量测试的结果</p>
<p>接下来开始一点一点说明如何操作</p>
<p>首先我们还是一样，选择要验证的文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的文件名为<code>math_add_mul.py</code></p>
<p>接下来还是照样，导入模块和继承方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> math_add_mul <span class="keyword">import</span> add, multiply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdd</span>(unittest.TestCase):</span><br></pre></td></tr></table></figure>

<p>这里由于需要演示测试套件，所以用了两个<code>TestCase</code></p>
<p>完整的如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> math_add_mul <span class="keyword">import</span> add, multiply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_negative</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(-<span class="number">2</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_float</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertAlmostEqual(add(<span class="number">0.1</span>, <span class="number">0.6</span>), <span class="number">0.7</span>, places=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMul</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(<span class="number">5</span>, <span class="number">6</span>), <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul_negative_1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(<span class="number">5</span>, -<span class="number">6</span>), -<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul_negative_2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(-<span class="number">5</span>, -<span class="number">6</span>), <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>接下来是创建一个测试套件，也就是<code>unittest.TestSuite()</code></p>
<p>这个套件的作用是可以往里面添加测试，之后运行这个套件，可以实现一次性执行多个测试的效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_suite</span>():</span><br><span class="line">    suite = unittest.TestSuite()</span><br></pre></td></tr></table></figure>

<p>接下来是往这个套件里面添加测试，将会用到这个方法：<code>addTest()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suite.addTest(TestAdd(<span class="string">&#x27;test_add&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>addTest</code>里面填写的是类<code>TestAdd</code>，而类的里面填写的是要执行的测试</p>
<p>也就是这个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>当然，这样一个一个添加还是太慢了，还可以用一个可迭代对象（比如列表）来添加</p>
<p>但需要注意的一点是这里用的不再是<code>addTest()</code>，而是<strong>addTests</strong>（注意末尾多了个<strong>s</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suite.addTests([TestAdd(<span class="string">&#x27;test_add&#x27;</span>),TestAdd(<span class="string">&#x27;test_add_negative&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>如果一个类里面有几百条测试，这样加还是有点慢，那有没有更快的方法呢？</p>
<p>当然有，你还可以把整个类添加进去，这里需要用到的还是<code>addTest()</code>方法，而在括号里面，需要用到另一个方法<code>makeSuite()</code></p>
<p>这个方法的作用是测试指定类中的所有测试，同时把这些测试组装成一个<code>TestSuite</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suite.addTest(unittest.makeSuite(TestMul))</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，便是测试了类<code>TestMul</code>中的所有测试</p>
<p>相较于一个一个加测试，使用这种方法在大规模测试中会更加方便</p>
<p>完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_suite</span>():</span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTests([TestAdd(<span class="string">&#x27;test_add&#x27;</span>), TestAdd(<span class="string">&#x27;test_add_negative&#x27;</span>)])</span><br><span class="line">    suite.addTest(unittest.makeSuite(TestMul))</span><br><span class="line">    <span class="keyword">return</span> suite</span><br></pre></td></tr></table></figure>

<p>接下来是执行的部分</p>
<p>首先你需要创建一个实例用来测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runner = unittest.TextTestRunner(verbosity=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>verbosity = 2</code>代表着详细输出，<code>verbosity = 1</code>代表了简略输出（用<code>.</code>表示通过，<code>F</code>表示失败）</p>
<p>此外还有<code>stream</code>参数，这个参数的作用是<strong>指定输出流</strong>，默认是<code>sys.stdout</code>（也就是控制台），可以自己重定向到文件中，这样就可以实现保存测试结果</p>
<p>另外一个参数为<code>descriptions</code>作用是是否显示测试方法中的文档字符串（Docstring），默认为<code>True</code></p>
<p>在完成设置后，就得开始执行测试了，需要用到这个方法<code>run()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_test.run(create_suite())</span><br></pre></td></tr></table></figure>

<p>这里括号内的<code>create_suite()</code>便是之前定义的测试套件</p>
<p>最后完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> math_add_mul <span class="keyword">import</span> add, multiply</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdd</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_negative</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(add(-<span class="number">2</span>, <span class="number">3</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_float</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertAlmostEqual(add(<span class="number">0.1</span>, <span class="number">0.6</span>), <span class="number">0.7</span>, places=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestMul</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(<span class="number">5</span>, <span class="number">6</span>), <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul_negative_1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(<span class="number">5</span>, -<span class="number">6</span>), -<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mul_negative_2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.assertEqual(multiply(-<span class="number">5</span>, -<span class="number">6</span>), <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_suite</span>():</span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTests([TestAdd(<span class="string">&#x27;test_add&#x27;</span>), TestAdd(<span class="string">&#x27;test_add_negative&#x27;</span>)])</span><br><span class="line">    suite.addTest(unittest.makeSuite(TestMul))</span><br><span class="line">    <span class="keyword">return</span> suite</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run_test = unittest.TextTestRunner(verbosity=<span class="number">2</span>)</span><br><span class="line">    run_test.run(create_suite())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>偏函数是<code>functools</code>模块中的一个功能，其主要作用是固定原函数的部分参数，而后生成一个新的函数</p>
<p>利用偏函数可以简化函数调用时的参数传递</p>
<p>首先需要导入这个模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br></pre></td></tr></table></figure>
<p>上面这个例子是导入了<code>functools</code>中的<code>partial</code>方法，也是偏函数的基础</p>
<p>接下来让我们从一个例子开始逐步讲解偏函数的使用：</p>
<p>首先我们这里假设个场景：要求对输入的数字进行加法运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要运算的数字如下1,3,3 2,3,5 5,3,7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a_func(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a_func(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a_func(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：7</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现，在上面给的例子中，第二个数始终为<code>3</code>，这时候我们可以将<code>3</code>用偏函数固定，只输入<code>a</code>和<code>c</code>的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要运算的数字如下1,3,3 2,3,5 5,3,7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_func</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line">a_func_pa = partial(a_func,b = <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(a_func_pa(<span class="number">1</span>,c = <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(a_func_pa(<span class="number">2</span>,c = <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a_func_pa(<span class="number">5</span>,c = <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：7</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<p>接下来开始逐一解释</p>
<p>这里<code>partial(a_func,b = 3)</code>是偏函数的核心所在，第一个参数填的是函数名称，也就是要调用的函数，而第二个参数填的是要固定的参数名和对应的参数值</p>
<p>这里偏函数被赋值给了变量<code>a_func_pa</code>，在变量后面的是剩余未被固定的参数<code>a</code>和<code>c</code></p>
<p>由于固定的参数是在中间的<code>b</code>，这里如果<code>c</code>不加关键字参数，那么函数会找不到参数。这里必须为关键字参数的原因是函数参数传递是按顺序的，而中间<code>b</code>函数无法直接跳过，所以只能用关键字参数传递</p>
<p>接下来再提供一个例子：二进制转为十六进制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">binary_l = [<span class="string">&quot;101000011&quot;</span>, <span class="string">&quot;111011110&quot;</span>, <span class="string">&quot;111011000&quot;</span>]</span><br><span class="line"></span><br><span class="line">binary_pa = partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> binary_l:</span><br><span class="line">    <span class="built_in">print</span>(binary_pa(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：323</span></span><br><span class="line"><span class="comment"># 478</span></span><br><span class="line"><span class="comment"># 472</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，这里将<code>int()</code>中的参数<code>base</code>固定为2，此时后面在输出十进制的时候便不需要再次说明<code>base</code>的值</p>
<hr>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存是Python中一个十分好用的装饰器，可以提高反复调用的函数的执行效率，主要使用到<code>functools</code>中的<code>lru_cache</code> </p>
<p>接下来通过一个例子来说明该如何使用</p>
<p>首先需要导入这个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br></pre></td></tr></table></figure>

<p>在导入后，我们需要把函数放到这个装饰器下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> pell(n-<span class="number">1</span>) * <span class="number">2</span> + pell(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这里装饰器括号内指的是缓存数量，超过这个数量就会删除旧的缓存同时生成新的缓存</p>
<p>之后便可以正常调用函数运行</p>
<p>接下来给出没有缓存和缓存的对比：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">n</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(n)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;运行时间为：<span class="subst">&#123;end_time - start_time:<span class="number">.10</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> pell(n-<span class="number">1</span>) * <span class="number">2</span> + pell(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pell(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 无缓存：运行时间为：0.0016508102</span></span><br><span class="line"><span class="comment"># 2378</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 有缓存：运行时间为：0.0000865459</span></span><br><span class="line"><span class="comment"># 2378</span></span><br></pre></td></tr></table></figure>

<p>可以看到，有缓存时，运行时间大大提高了</p>
<h4 id="缓存存储"><a href="#缓存存储" class="headerlink" title="缓存存储"></a>缓存存储</h4><p>被<code>lru_cache</code>装饰的函数会新增两个方法<code>cache_info()</code>和<code>cache_clear()</code></p>
<p>接下来分别来介绍如何使用</p>
<p><strong>cache_info()</strong><br><code>cache_info</code>的作用是返回缓存的统计信息，其中包含四个部分：<code>hits</code>、<code>misses</code>、<code>maxsize</code>和<code>currsize</code></p>
<ul>
<li><code>hits</code>：缓存命中次数（直接返回缓存结果的次数）</li>
<li><code>misses</code>：缓存未命中次数（首次计算并缓存的次数）</li>
<li><code>maxsize</code>：缓存最大容量</li>
<li><code>currsize</code>：当前缓存条目数</li>
</ul>
<p>接下来给出例子：</p>
<p>以上面的例子作为示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">n</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(n)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;运行时间为：<span class="subst">&#123;end_time - start_time:<span class="number">.10</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    wrapper.cache_info = func.cache_info</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">128</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pell</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> pell(n-<span class="number">1</span>) * <span class="number">2</span> + pell(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pell(<span class="number">10</span>))</span><br><span class="line">info = pell.cache_info()</span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure>
<p>这里函数<code>wrapper()</code>新增了一行<code>wrapper.cache_info = func.cache_info</code></p>
<p>说明一下为什么要加这个</p>
<p>由于这里<code>pell()</code>套了两个装饰器，分别是<code>@timer</code>和<code>@lru_cache</code></p>
<p>而这里真正返回变量的是外层<code>@timer</code>中的<code>wrapper()</code>，但是<code>wrapper()</code>只是一个普通的函数，没有<code>cache_info</code></p>
<p>而加这一行的作用是把<code>func</code>（也就是<code>pell()</code>）的<code>cache_info</code>传给<code>wrapper()</code>，这样的话<code>wrapper()</code>就有了<code>cache_info</code></p>
<p>也就可以通过<code>cache_info()</code>调出缓存信息</p>
<p>而调出缓存的方法也很简单，具体为<code>函数名.cache_info()</code></p>
<p><strong>cache_clear</strong><br><code>cache_clear</code>的作用为清空缓存</p>
<p>使用方法同上：<code>函数名.cache_clear</code>：</p>
<h5 id="需要注意的几个点"><a href="#需要注意的几个点" class="headerlink" title="需要注意的几个点"></a>需要注意的几个点</h5><p>由于缓存本质上是用字典来储存的，所以函数的参数必须为<strong>可哈希</strong></p>
<p>不可以用列表和字典</p>
<p>此外，如果函数的结果依赖于外部状态（如当前时间），缓存会导致返回过期结果。</p>
<p>说的直白一点就是数据不再更新</p>
<hr>
<p><a href="common_terms.md">返回导航页</a></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>作者:</span>
                        <span>Gaizhedu</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E5%BD%92%E6%A1%A3/"># 归档</a>
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/archives/2025-08-12/k&r_ch1/">C程序设计语言（K&R）第一章</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Gaizhedu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>