<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Gaizhedu">





<title>集合（Collection） | Gaizhedu的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 8.1.1"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Gaizhedu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">文章</a>
                
                <a class="menu-item" href="/tag">标签</a>
                
                <a class="menu-item" href="/about">关于本站</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Gaizhedu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">文章</a>
                
                <a class="menu-item" href="/tag">标签</a>
                
                <a class="menu-item" href="/about">关于本站</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">展开全部</a>
        <a onclick="go_top()">返回顶部</a>
        <a onclick="go_bottom()">跳转底部</a>
    </div>
</div>

<script>

    var tocI18n = {
        expandAll: '展开全部',  // EJS 写法，NJK 用 {{ __('toc_expand_all') }}
        collapseAll: '全部折叠' // 先在 zh-CN.yml 里加这个键
    };

    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? tocI18n.expandAll : tocI18n.collapseAll;
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">集合（Collection）</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">Gaizhedu</a>
                    

                    
                        <span class="post-time">
                        日期: <a href="#">2025-10-24&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>[TOC]<br>[TODO]</p>
<ol>
<li>List接口<ul>
<li><input checked="" disabled="" type="checkbox"> ArrayList<ul>
<li><input checked="" disabled="" type="checkbox"> TODO clear()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO isEmply()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO contains()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO retainAll()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO toArray()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO spliterator()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO forEach()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO removeIf()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO stream()方法<ul>
<li><input checked="" disabled="" type="checkbox"> filter()</li>
<li><input checked="" disabled="" type="checkbox"> map()</li>
<li><input checked="" disabled="" type="checkbox"> mapMulti()</li>
<li><input checked="" disabled="" type="checkbox"> mapMultiToInt()</li>
<li><input checked="" disabled="" type="checkbox"> mapMultiToLong()</li>
<li><input checked="" disabled="" type="checkbox"> mapMultiToDouble()</li>
<li><input checked="" disabled="" type="checkbox"> mapToInt()</li>
<li><input checked="" disabled="" type="checkbox"> mapToLong()</li>
<li><input checked="" disabled="" type="checkbox"> mapToDouble()</li>
<li><input checked="" disabled="" type="checkbox"> flatMap()</li>
<li><input checked="" disabled="" type="checkbox"> flatMapToInt()</li>
<li><input checked="" disabled="" type="checkbox"> flatMapToLong()</li>
<li><input checked="" disabled="" type="checkbox"> flatMapToDouble()</li>
<li><input checked="" disabled="" type="checkbox"> distinct()</li>
<li><input checked="" disabled="" type="checkbox"> sorted()</li>
<li><input checked="" disabled="" type="checkbox"> peek()</li>
<li><input checked="" disabled="" type="checkbox"> limit()</li>
<li><input checked="" disabled="" type="checkbox"> skip()</li>
<li><input checked="" disabled="" type="checkbox"> takeWhile()</li>
<li><input checked="" disabled="" type="checkbox"> dropWhile()</li>
<li><input checked="" disabled="" type="checkbox"> forEach()</li>
<li><input checked="" disabled="" type="checkbox"> forEachOrdered()</li>
<li><input checked="" disabled="" type="checkbox"> toArray()</li>
<li><input checked="" disabled="" type="checkbox"> reduce()</li>
<li><input checked="" disabled="" type="checkbox"> collect()</li>
<li><input checked="" disabled="" type="checkbox"> min()</li>
<li><input checked="" disabled="" type="checkbox"> max()</li>
<li><input checked="" disabled="" type="checkbox"> count()</li>
<li><input checked="" disabled="" type="checkbox"> anyMatch()</li>
<li><input checked="" disabled="" type="checkbox"> allMatch()</li>
<li><input checked="" disabled="" type="checkbox"> noneMatch()</li>
<li><input checked="" disabled="" type="checkbox"> findFirst()</li>
<li><input checked="" disabled="" type="checkbox"> findAny()</li>
<li><input checked="" disabled="" type="checkbox"> gather()</li>
<li><input checked="" disabled="" type="checkbox"> toList()</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> TODO parallelStream()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO equals()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO hashCode()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO clone()方法</li>
<li><input checked="" disabled="" type="checkbox"> TODO toString()方法</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> LinkedList</li>
<li><input disabled="" type="checkbox"> （拓展）Vector</li>
<li><input disabled="" type="checkbox"> （拓展）Stack</li>
</ul>
</li>
<li>Set接口<ul>
<li><input checked="" disabled="" type="checkbox"> HashSet</li>
<li><input checked="" disabled="" type="checkbox"> TreeSet</li>
<li><input disabled="" type="checkbox"> （拓展）LinkedHashSet</li>
<li><input disabled="" type="checkbox"> （拓展）ConcurrentSkipListSet</li>
<li><input disabled="" type="checkbox"> （拓展）CopyOnWriteArraySet</li>
</ul>
</li>
<li>（拓展）Queue接口<ul>
<li><input disabled="" type="checkbox"> ArrayDeque</li>
<li><input disabled="" type="checkbox"> LinkedList</li>
<li><input disabled="" type="checkbox"> PriorityQueue</li>
<li><input disabled="" type="checkbox"> ConcurrentLinkedQueue</li>
<li><input disabled="" type="checkbox"> ArrayBlockingQueue</li>
<li><input disabled="" type="checkbox"> DelayQueue</li>
</ul>
</li>
<li>（扩展）配套工具<ul>
<li><input disabled="" type="checkbox"> 迭代器（Iterator）</li>
<li><input disabled="" type="checkbox"> 集成工具类（Collections）</li>
</ul>
</li>
</ol>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>这一份将介绍有关Collection这个抽象类的相关内容</p>
<p>首先，通过这里的描述我们也清楚了，这个类是一个抽象类，所以是没办法直接使用的</p>
<p>所以我们一般使用的是他的子接口，而他的子接口又有许多具体的实现类</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>这个接口是List接口，具体的实现类有如下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList : 动态数组</span><br><span class="line">LinkedList : 双向列表</span><br><span class="line">Vector : 动态数组</span><br><span class="line">Stack : 继承与Vector</span><br></pre></td></tr></table></figure>

<p>接下来开始一一介绍</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>首先是ArrayList</p>
<p>这个属于动态数组，也就是说如果空间不够会自己扩容</p>
<h4 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h4><p>接下来讲讲如何创建一个ArrayList</p>
<p>最基本的框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;具体类型&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;泛型&gt;(构造器参数);</span><br></pre></td></tr></table></figure>

<p>接下来分别讲一下这里的各个内容</p>
<p>首先第一个，ArrayList 后面跟着的具体类型，这个具体类型的作用为：将泛型类 &#x2F; 接口具体化</p>
<p>也就是说通过具体的类型来约束集合的操作，使得最后编译的时候类型安全</p>
<p>如何理解呢？类型实参可以给这个参数（lst）赋予一个具体的类型，而编译器会在编译的时候根据类型的实参在编译阶段就检查集合的取和存操作是否符合约定</p>
<p>也就是说，使用类型实参可以有效地防止了添加错误的类型，避免了运行时的转换错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;NewObject&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 正确做法，上面类型实参为NewObject，意味着这里只能填该类型的变量</span></span><br><span class="line">lst.add(<span class="keyword">new</span> <span class="title class_">NewObject</span>(...));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误做法，不应该为字符串String类型</span></span><br><span class="line">lst.add(<span class="string">&quot;This is a String&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="为什么要这样干"><a href="#为什么要这样干" class="headerlink" title="为什么要这样干"></a>为什么要这样干</h5><p>有人可能就要问了，那为什么要这样干呢？</p>
<p>我们不妨假设一下，如果不进行这样，而是使用错误的做法那会怎么样</p>
<p>如果我们选择<code>lst.add(&quot;This is a String&quot;)</code>——也就是传入一个字符串</p>
<p>那么在之后读取lst的元素的时候，由于强制类型转换的原因，程序会抛出<code>ClassCastException</code>的错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">NewObject</span> <span class="variable">newObject</span> <span class="operator">=</span> (NewObject) lst.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(newObject.getObjectName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：Exception in thread &quot;main&quot; java.lang.ClassCastException</span></span><br></pre></td></tr></table></figure>

<p>如果我们有通过填写类型实参来检查，那么就可以在编译的阶段解决这个问题</p>
<hr>
<p>当然，使用参数实参肯定是不止这个的</p>
<p>如果使用类型实参，便可以减少在代码中出现的强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处未填类型实参</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">lst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="keyword">new</span> <span class="title class_">NewObject</span>(<span class="string">&quot;测试1&quot;</span>, <span class="number">1</span>));</span><br><span class="line"><span class="type">NewObject</span> <span class="variable">newObject</span> <span class="operator">=</span> (NewObject) lst.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(newObject.getObjectName());</span><br></pre></td></tr></table></figure>

<p>如果使用类型实参则会是这样的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;NewObject&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="keyword">new</span> <span class="title class_">NewObject</span>(<span class="string">&quot;测试1&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="type">NewObject</span> <span class="variable">newObject</span> <span class="operator">=</span> lst.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(newObject.getObjectName());</span><br></pre></td></tr></table></figure>
<p>这里便可以不用手动强制类型转换，大大减少了问题的出现</p>
<p>接下来是后面的创建内容，首先是尖括号里面的内容</p>
<p>第一个部分是ArrayList后面跟着的尖括号<code>&lt;&gt;</code>，这个尖括号主要是起到泛型的作用，在尖括号里面填入指定的类型可以起到限定此类才可以传入的效果</p>
<p>不过由于版本更替，如果你在类型实参中已经有填写，那么其实是没必要在后面的尖括号里面填写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型为String</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>这里其实把泛型的内容省略的，在Java 7+后，编译器会自动匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里泛型没有填写，因为编译器会自己自动匹配</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h6 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h6><p>如果你需要指定泛型为整数类，或者是浮点数类</p>
<p>必须要使用其包装类，而不能使用基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>&gt;();<span class="comment">// 错误，不应该使用基本数据类型</span></span><br><span class="line">ArrayList&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">// 正确，使用了整数类型的包装类</span></span><br></pre></td></tr></table></figure>

<hr>
<p>接下来讲讲圆括号内的内容</p>
<p>圆括号主要是调用构造方法，你可以在这里面指定默认的大小，或者是复制一个集合到这里面去</p>
<p>如果你在圆括号里面填写一个数字，便可以直接指定这个集合的默认大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将这个集合的默认大小指定为10个元素</p>
<p>如果你选择不填写（也就是默认），那么这个集合的长度将会设定为10个的大小</p>
<p>接下来是另一个，复制集合</p>
<p>假设我们之前已经创建过一个集合，并且往这个集合里面填写了元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; source = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">source.add(<span class="string">&quot;New Collection&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么我们便可以在新的集合的圆括号里面填写这个集合的名字（例如这里是source）</p>
<p>这样便可以把旧集合的元素复制到新的集合里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; source = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">source.add(<span class="string">&quot;New Collection&quot;</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(source);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// New Collection</span></span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>那么有什么特点呢？首先第一个就是ArrayList是一个动态数组，也就是说，其可以自动的扩容</p>
<p>假设我们一开始的长度为10，将这个10个大小全部用完后，这个数组会自动扩容，默认扩容大小为原大小的1.5倍</p>
<p>为什么是1.5倍呢？如果倍率太小，那么扩容的空间太小，扩容的次数便会大大增加，这意味着会频繁的复制元素</p>
<p>但是复制元素是耗时的，所以倍率太小会导致浪费一些时间</p>
<p>既然这样，那为什么不要选择大一点的倍率呢？</p>
<p>这是因为如果倍率太大，可能会导致占用过多的内存</p>
<p>权衡之下，选择1.5倍是最好的选择</p>
<hr>
<p>ArrayList还有一些特性</p>
<p>作为一种动态数组，ArrayList支持存放相同元素</p>
<p>ArrayList可以存放<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>ArrayList具有有序性，意味着元素的插入顺序和访问顺序是一致的</p>
<p>在访问ArrayList的元素的时候，通过索引<code>get(int index)</code>可以很快地找到元素</p>
<p>其时间复杂度为：<strong>O(1)</strong></p>
<p>假设需要往这个数组中间插入或者删除元素，那么其时间复杂度为：O(n)</p>
<p>这是因为每次从其中删除或者添加元素的时候需要将这个元素后面的元素移动一个单位</p>
<p>此外，由于ArrayList的所有方法都是没有同步锁的，这就导致了多线程操作的时候可能会出现并发的问题</p>
<p>如果需要线程安全，那么可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<p>使用集成工具类中的<code>synchronizedList</code>方法，便可以解决多线程的问题</p>
<blockquote>
<p>当然这里也可以直接使用CopyOnWriteArrayList</p>
</blockquote>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>这里将接下ArrayList的一些具体使用方法</p>
<blockquote>
<p>由于这些方法基本上是通用的，所以在这里讲过一次后，接下来的实现类便不会再讲<br>ArrayList包括了List接口的所有方法</p>
</blockquote>
<p><strong>add()</strong><br><code>add()</code>方法用于往数组末尾添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前列表长度为：%d，添加的元素为：%s\n&quot;</span>,list.size(),list.getLast());</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第二个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前列表长度为：%d，添加的元素为：%s\n&quot;</span>,list.size(),list.getLast());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前列表长度为：1，添加的元素为：往末尾添加第一个新元素</span></span><br><span class="line"><span class="comment">// 当前列表长度为：2，添加的元素为：往末尾添加第二个新元素</span></span><br></pre></td></tr></table></figure>

<p>如果在添加元素的时候发现数组不够用了，那么会先扩容在添加</p>
<p>此外，<code>add()</code>还可以指定插入的位置</p>
<p>假设我们想要插入的位置为第二项，那么只需要这样填写参数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">1</span>,<span class="string">&quot;插入第二项&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第一个参数为插入的位置，由于数组计数从零开始，所以这里得填写1来代表第二项</p>
<p>而第二个参数代表插入的内容</p>
<p><strong>get()</strong><br><code>get()</code>为返回指定索引位置的元素</p>
<p>需要注意的一点是，这里返回的内容其实为底层数组<code>elementData[index]</code></p>
<h5 id="什么是elementData"><a href="#什么是elementData" class="headerlink" title="什么是elementData"></a>什么是elementData</h5><p>这里可能就有人要问了，诶，那什么是elementData呢？</p>
<p>在ArrayList.java里面是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以基本理解，这个<code>elementData</code>便是ArrayList底层的数组，平时丢进去的元素都会存放在这里面</p>
<hr>
<p>接下来回到正题，get()通过访问底层数组<code>elementData</code>来获取到指定位置的元素</p>
<p>假设此时索引的范围超过底层数组（也就是越界），或者数组的这个位置没有任何元素，那么会抛出这个错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前列表长度为：%d，添加的元素为：%s\n&quot;</span>,list.size(),list.getLast());</span><br><span class="line"><span class="comment">// 数组只有一个元素，索引第二个元素（get(1)）会导致报错</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%s&quot;</span>,list.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前列表长度为：1，添加的元素为：往末尾添加第一个新元素</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>set()</strong><br>接下来是<code>set()</code></p>
<p>这个方法的作用是替换指定位置的元素为新的元素</p>
<p>这个方法具有两个参数：</p>
<p>第一个参数为替换的位置，而第二个参数为想要替换的新元素</p>
<p>与上文的<code>get()</code>同理，这里本质也是对底层的数组<code>elementData</code>进行修改</p>
<p>此处也需要先检查是否越界，如果越界一样会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第二个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;未替换的元素为：%s\n&quot;</span>,list.get(<span class="number">1</span>));</span><br><span class="line">list.set(<span class="number">1</span>,<span class="string">&quot;新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;替换的元素为：%s\n&quot;</span>, list.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 未替换的元素为：往末尾添加第二个新元素</span></span><br><span class="line"><span class="comment">// 替换的元素为：新元素</span></span><br></pre></td></tr></table></figure>

<p>此处为什么不写成这样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第二个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;未替换的元素为：%s\n&quot;</span>,list.get(<span class="number">1</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;替换的元素为：%s\n&quot;</span>, list.set(<span class="number">1</span>,<span class="string">&quot;新元素&quot;</span>););</span><br></pre></td></tr></table></figure>

<p>这是由于在<code>ArrayList.java</code>中，<code>set()</code>的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">   Objects.checkIndex(index, size);</span><br><span class="line">   <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">   elementData[index] = element;</span><br><span class="line">   <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里现将变量<code>oldValue</code>赋值为旧的值<code>elementData(index)</code></p>
<p>而后才替换为新的值<code>elementData[index] = element;</code></p>
<p>而返回的值为<code>oldValue</code>，这意味着返回的结果为替换前的值</p>
<p><strong>remove()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前列表长度为：%d，添加的元素为：%s\n&quot;</span>,list.size(),list.getLast());</span><br><span class="line">System.out.printf(<span class="string">&quot;%s&quot;</span>,list.remove(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前列表长度为：1，添加的元素为：往末尾添加第一个新元素</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>
<p>如果当前位置有元素，那么会返回这个删除的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第二个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;删除的元素为：%s\n&quot;</span>,list.remove(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 删除的元素为：往末尾添加第二个新元素</span></span><br></pre></td></tr></table></figure>

<p>诶，在之前也有提到一个点：</p>
<blockquote>
<p>假设需要往这个数组中间插入或者删除元素，那么其时间复杂度为：O(n)</p>
<p>这是因为每次从其中删除或者添加元素的时候需要将这个元素后面的元素移动一个单位</p>
</blockquote>
<p>这里的意思是，在删除一个中间元素后会将后面的所有元素向前移动一个单位，说白了就是将后面的元素复制一遍</p>
<p>从底层代码我们也可以看到这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">   Objects.checkIndex(index, size);</span><br><span class="line">   <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) es[index];</span><br><span class="line">   fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">   modCount++;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> newSize;</span><br><span class="line">   <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)</span><br><span class="line">      System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">   es[size = newSize] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察这段代码，我们也可以发现一个很有意思的点</p>
<p><code>remove()</code>移除指定位置的底层实现，其实是<strong>覆盖</strong>，也就是先将这个元素后面的所有元素移动前一位，而后将原本的最后一位设定为null</p>
<p>为什么要设定为null呢？这里其实在帮助GC回收</p>
<p>举个具体例子</p>
<p>假设我们有个数组为100位</p>
<p>我想要删除第50位，那么底层的实现是这样的：</p>
<p>先复制51~100位的元素到50~99位，之后设定100位为<code>null</code></p>
<p>之后返回替换前的50位</p>
<p><strong>size()</strong><br>接下来是<code>size()</code></p>
<p>size()的作用是返回底层数组所拥有元素的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第一个新元素&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;往末尾添加第二个新元素&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;数组长度为：%s&quot;</span>,list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 数组长度为：2</span></span><br></pre></td></tr></table></figure>

<p><strong>clear()</strong><br>接下来是<code>clear()</code></p>
<p>这个方法比较简单，主要的作用是清空当前数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">lst.clear();</span><br><span class="line">lst.add(<span class="string">&quot;又新增回来了&quot;</span>);</span><br><span class="line">System.out.println(lst);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [又新增回来了]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在使用<code>clear()</code>方法后，这个数组中的元素便被清空了，之后输出也是重新添加的元素</p>
<p>这个方法的代码实现也很简单粗暴：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">   modCount++;</span><br><span class="line">   <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> size, i = size = <span class="number">0</span>; i &lt; to; i++)</span><br><span class="line">      es[i] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是将操作数<code>modCount</code>增加一个单位，之后便将es赋值为这个数组</p>
<p>赋值后便是一个简单的for循环，这个for循环中的条件中size为数组长度</p>
<p>这里有个很巧妙的点，我们在使用clear后数组为空，此时数组长度为0</p>
<p>此处在赋值给to后又使用了<code>i = size = 0</code>，这样就使得数组长度被设定为0，符合清空的情况</p>
<p>循环语句的作用为将这个数组的每一项都设定为null值，利用这种方法来实现清空数组</p>
<p><strong>isEmply()</strong><br>接下来介绍isEmply方法，这个方法的主要作用是检测当前数组是否为空，如果为空则返回true，否则返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前数组状态（是否为空）：%s\n&quot;</span>, lst.isEmpty());</span><br><span class="line">lst.clear();</span><br><span class="line">System.out.printf(<span class="string">&quot;当前数组状态（是否为空）：%s\n&quot;</span>, lst.isEmpty());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前数组状态（是否为空）：false</span></span><br><span class="line"><span class="comment">// 当前数组状态（是否为空）：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在执行clear方法将数组清空后，<code>isEmpty()</code>显示为<code>true</code></p>
<p>代码实现也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里的代码实现就是通过检测数组大小是否为0，并且返回结果</p>
<p><strong>contains()</strong><br>接下来是contains方法</p>
<p>这个方法有一个参数可选：<code>contains(Object o)</code></p>
<p>其中<code>参数o</code>代表需要检测的元素</p>
<p>这个方法的检测当前数组中是否有括号内的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; lst = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">lst.add(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前数组是否有目标元素：%s\n&quot;</span>, lst.contains(<span class="string">&quot;你好！&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前数组是否有目标元素：true</span></span><br></pre></td></tr></table></figure>
<p>假设这个数组内有该元素，那么则会返回true</p>
<p>那么他的代码实现是怎么样的呢？</p>
<p>其实很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法实际上是复用了<code>indexOf</code>的方法，并通过这个方法的返回值是否大于等于0来判断是否为true</p>
<p>为什么可以这样呢？其实很简单，因为这个方法实际上是返回该元素所在位置</p>
<p>如果没有该元素，则返回-1</p>
<p>通过这种形式，成功精简了代码</p>
<blockquote>
<p>此处实现了DRY原则</p>
</blockquote>
<p><strong>retainAll()</strong><br>接下来介绍这个方法</p>
<p>这个方法拥有一个参数：<code>retainAll(Collection&lt;?&gt; c)</code></p>
<p>这个参数的意思是支持所有实现Collection接口的集合，例如List接口，Set接口</p>
<p>这个方法的主要用法是<code>A.retainAll(B)</code>（A和B都是符合条件的数组）</p>
<p>这里代表将A赋值为A和B的交集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   arrayList.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">   arrayList1.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;当前数组arrayList1：\n%s\n&quot;</span>, arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;当前数组arrayList：\n%s\n&quot;</span>, arrayList1);</span><br><span class="line">arrayList1.retainAll(arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;交集后数组：\n%s&quot;</span>, arrayList1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前数组treeSet：</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">// 当前数组lst：</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]</span></span><br><span class="line"><span class="comment">// 交集后数组：</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<p><strong>toArray()</strong><br>接下来来讲讲这个方法</p>
<p>首先这个方法拥有一个参数：<code>toArray(T[] a)</code></p>
<p>完整的版本如下：<code>&lt;T&gt; T[] toArray(T[] a)</code></p>
<p>当然也有没参数的版本：<code>Object[] toArray()</code></p>
<p>这个方法的作用是将一个<strong>集合转变为数组</strong></p>
<p>接下来将分别演示带参数和不带参数的版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt(<span class="number">0</span>, <span class="number">201</span>);</span><br><span class="line">   treeSet.add(randomNumber);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;treeSet属于的类型：%s\n&quot;</span>, treeSet.getClass().getSimpleName());</span><br><span class="line">Object[] newTreeSet = treeSet.toArray();</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet属于的类型：%s\n&quot;</span>, newTreeSet.getClass().getSimpleName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// treeSet属于的类型：TreeSet</span></span><br><span class="line"><span class="comment">// newTreeSet属于的类型：Object[]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里选择了不加参数的版本，对应的类型也是选择了：<code>Object</code></p>
<p>但是一般来讲并不建议使用这种做法，因为这种做法在使用的时候一般需要进行强制类型转换，如果不进行强制类型转化，那么会导致报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt(<span class="number">0</span>, <span class="number">201</span>);</span><br><span class="line">   treeSet.add(randomNumber);</span><br><span class="line">&#125;</span><br><span class="line">Object[] newTreeSet = treeSet.toArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">addNumber</span> <span class="operator">=</span> (Integer) newTreeSet[<span class="number">0</span>] + (Integer) newTreeSet[<span class="number">1</span>];</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项为：%d\n&quot;</span>, newTreeSet[<span class="number">0</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第二项为：%d\n&quot;</span>, newTreeSet[<span class="number">1</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项与第二项相加：%d\n&quot;</span>, addNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// newTreeSet第一项为：5</span></span><br><span class="line"><span class="comment">// newTreeSet第二项为：7</span></span><br><span class="line"><span class="comment">// newTreeSet第一项与第二项相加：12</span></span><br></pre></td></tr></table></figure>

<p>上面是正确做法，但是不正确会怎么样呢（不正确也就是没有使用强制类型转换）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt(<span class="number">0</span>, <span class="number">201</span>);</span><br><span class="line">   treeSet.add(randomNumber);</span><br><span class="line">&#125;</span><br><span class="line">Object[] newTreeSet = treeSet.toArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">addNumber</span> <span class="operator">=</span> newTreeSet[<span class="number">0</span>] + newTreeSet[<span class="number">1</span>];</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项为：%d\n&quot;</span>, newTreeSet[<span class="number">0</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第二项为：%d\n&quot;</span>, newTreeSet[<span class="number">1</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项与第二项相加：%d\n&quot;</span>, addNumber);</span><br></pre></td></tr></table></figure>
<p>上面便是没有使用强制类型转换的代码，如果没有使用强制类型转化，则会显示出：</p>
<p><code>运算符 &#39;+&#39; 不能应用于 &#39;java.lang.Object&#39;、&#39;java.lang.Object&#39;</code></p>
<p>但如果使用带参数的形式，那么便可以十分简单地解决这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> random.nextInt(<span class="number">0</span>, <span class="number">201</span>);</span><br><span class="line">   treeSet.add(randomNumber);</span><br><span class="line">&#125;</span><br><span class="line">Integer[] newTreeSet = treeSet.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> <span class="variable">addNumber</span> <span class="operator">=</span> newTreeSet[<span class="number">0</span>] + newTreeSet[<span class="number">1</span>];</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项为：%d\n&quot;</span>, newTreeSet[<span class="number">0</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第二项为：%d\n&quot;</span>, newTreeSet[<span class="number">1</span>]);</span><br><span class="line">System.out.printf(<span class="string">&quot;newTreeSet第一项与第二项相加：%d\n&quot;</span>, addNumber);</span><br></pre></td></tr></table></figure>

<p>上面这里将原本的<code>Object[]</code>替换为<code>Integer[]</code>，相对应的，后面的参数也要填写对应的类型</p>
<p>在这里例子中，两个项数相加的时候便没有使用强制类型转换</p>
<p>在一般情况下都是建议使用带参数的版本的，一方面这样更加安全，另一方面，不带参的版本属于历史遗留问题</p>
<p>从性能角度看，不带参数每次都需要创建新的数组，而带参数的可能会复用传入的数组</p>
<p><del>当然，除非你真的需要用到<code>Object</code></del></p>
<p>这里我们可以补充一个内容，上文的带参数的形式使用了<code>new Integer[0]</code></p>
<p>那么这里的<code>[0]</code>是什么意思呢</p>
<p>其实这里是在声明创建数组的大小，那么有人就要问了：诶，0不是代表长度为0吗？</p>
<p>是的，但是Java在创建数组的时候有一个有意思的特性：</p>
<p>如果传入的集合大小是刚好与创建的数组声明的大小是一致的，那么会直接存入并返回</p>
<p>如果是小于（也就是空间不足），那么会创建新数组并返回</p>
<p>如果是大于的，那么则会在存入集合后把多余的空间用<strong>null</strong>填充</p>
<h5 id="补充点：为什么要使用数组"><a href="#补充点：为什么要使用数组" class="headerlink" title="补充点：为什么要使用数组"></a>补充点：为什么要使用数组</h5><p>说了这么多，还没有提及到<strong>为什么要使用数组</strong></p>
<p>确实，原先的集合已经很方便了，但是在性能上，数组的是要比集合更加好的：</p>
<p>我们这里就以ArrayList为例，这个集合的底层实现也是数组</p>
<p>首先，我们需要搞懂ArrayList到底是怎么存的</p>
<p>说的简单粗暴一点，其实里面存的东西实际上并不是直接的元素，而是<strong>指向对应元素的引用</strong></p>
<blockquote>
<p>这一点其实有点像C中的指针</p>
</blockquote>
<p>这就导致了什么，每次查询都是间接查询，而不是直接查询</p>
<p>但是数组呢？由于其特性，每个元素都是按顺序排序的</p>
<p>这就导致了在查询的时候时间十分快</p>
<p>并且由于不用间接可以直接查询</p>
<p>这种特性对于CPU的缓存是更好的</p>
<p>在这一点上，数组性能是要高于集合的，尽管这两者实际使用效果差不多</p>
<p><strong>forEach</strong><br>forEach方法是一个用于批量操作的方法</p>
<p>其带有一个参数：<code>forEach(Consumer&lt;? super E&gt; action)</code></p>
<p>这个参数的意思是在里面输入相对应的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arrayList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 142</span></span><br><span class="line"><span class="comment">// 143</span></span><br><span class="line"><span class="comment">// 92</span></span><br></pre></td></tr></table></figure>
<p>这里的意思的将arrayList的所有元素都使用<code>System.out</code>中的<code>println</code>方法输出</p>
<p>除了这种简单的方法，forEach方法还可以使用代码块来定义行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line">arrayList.forEach(array -&gt; &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">square</span> <span class="operator">=</span> array * array;</span><br><span class="line">   System.out.printf(<span class="string">&quot;原数字为：%d，平方数字为：%d\n&quot;</span>, array, square);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数字为：188，平方数字为：35344</span></span><br><span class="line"><span class="comment">// 原数字为：11，平方数字为：121</span></span><br><span class="line"><span class="comment">// 原数字为：35，平方数字为：1225</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！在使用的过程中不可使用任何会引起modCount改变的方法，否则会抛出报错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line">arrayList.forEach(array -&gt; &#123;</span><br><span class="line">   arrayList.add(<span class="number">123</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">square</span> <span class="operator">=</span> array * array;</span><br><span class="line">   System.out.printf(<span class="string">&quot;原数字为：%d，平方数字为：%d\n&quot;</span>, array, square);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>
<p>上面使用了<code>add</code>，这个方法会导致<code>modCount</code>发生改变，所以不可以使用</p>
<p>不过Iterator的remove是可以使用的，原因之前也提及到的</p>
<p>接下来需要补充一个点，就是forEach方法是无法获取到遍历的下标的，如果需要索引下标，则必须自己新增变量自增获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] lstIndex = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">arrayList.forEach(array -&gt; &#123;</span><br><span class="line">   System.out.printf(<span class="string">&quot;当前下标为%d\n&quot;</span>, lstIndex[<span class="number">0</span>]++);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前下标为0</span></span><br><span class="line"><span class="comment">// 当前下标为1</span></span><br><span class="line"><span class="comment">// 当前下标为2</span></span><br></pre></td></tr></table></figure>

<p><strong>removeIf()</strong><br>接下来介绍这个方法</p>
<p>这个方法有一个参数：</p>
<p>这个参数代表可以选择的筛选方法</p>
<p>这个方法的作用就是根据筛选的方法来删除指定元素，如果满足条件则删除该元素</p>
<p>筛选方法依旧支持Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">500</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：\n%s\n&quot;</span>, arrayList);</span><br><span class="line">arrayList.removeIf(array -&gt; array % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后的数组：\n%s\n&quot;</span>, arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：</span></span><br><span class="line"><span class="comment">// [211, 118, 450, 306, 130, 204, 223, 334, 444, 212]</span></span><br><span class="line"><span class="comment">// 筛选后的数组：</span></span><br><span class="line"><span class="comment">// [211, 118, 130, 223, 334, 212]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，上面的数组一部分满足条件的元素被删除了</p>
<p>这个方法还可以用于删除<code>null</code>值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (random.nextBoolean()) &#123;</span><br><span class="line">         arrayList.add(random.nextInt(<span class="number">0</span>, <span class="number">500</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         arrayList.add(<span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：\n%s\n&quot;</span>, arrayList);</span><br><span class="line">arrayList.removeIf(Objects::isNull);</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后的数组：\n%s\n&quot;</span>, arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：</span></span><br><span class="line"><span class="comment">// [491, null, 141, 395, 313, null, 168, 487, 6, 216]</span></span><br><span class="line"><span class="comment">// 筛选后的数组：</span></span><br><span class="line"><span class="comment">// [491, 141, 395, 313, 168, 487, 6, 216]</span></span><br></pre></td></tr></table></figure>

<p><strong>equals()</strong><br>接下来介绍这个方法</p>
<p>这个方法的作用为判断是否相等</p>
<p>这个方法有一个参数：<code>equals(Object o)</code></p>
<p>参数o代表一个对象</p>
<p>在这里的用法为判断两个集合的元素是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList1.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;判断两个集合是否相等：%s&quot;</span>,arrayList.equals(arrayList1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 判断两个集合是否相等：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这两个集合的元素完全一致，所以返回<code>true</code></p>
<p>注意，如果两者属于不同接口，那么即使元素相同也会返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(i);</span><br><span class="line">   treeSet.add(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;判断两个集合是否相等：%s&quot;</span>,arrayList.equals(treeSet));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 判断两个集合是否相等：false</span></span><br></pre></td></tr></table></figure>
<p>这里分别为两个不同的接口，所以即使内容相同，也是返回<code>false</code></p>
<p>但如果接口相同，内容相同，但是实现类不同，那也是会正常返回<code>true</code>的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">System.out.printf(<span class="string">&quot;两个集合是否相等：%s&quot;</span>,linkedList.equals(arrayList));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 两个集合是否相等：true</span></span><br></pre></td></tr></table></figure>

<p>为什么会这样？这是因为在源码中已经写清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里的第二个if语句便是判断是否属于同一接口的方法，上文输出为false的例子一个为List接口，而另一个为Set接口，所以返回为false</p>
<h5 id="补充点：null安全"><a href="#补充点：null安全" class="headerlink" title="补充点：null安全"></a>补充点：null安全</h5><p>这里补充一点，<code>equals()</code>方法是<strong>null安全</strong>的</p>
<p>什么是null安全呢？简单来说就是在处理集合中的null元素的时候不会抛出空指针报错：<code>NullPointerException</code></p>
<p>那么为什么要特意强调这一点呢？</p>
<p>因为在Java中null指的是<strong>没有指向任何对象的引用</strong></p>
<p>如果试图对null调用任何方法，则会抛出<strong>NullPointerException</strong></p>
<p>但是<code>equals()</code>是如何处理的呢？</p>
<p>可以在源码里面看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这里是一个三元表达式，具体的逻辑如下：</p>
<p>如果o1为null，那么则判断o2是否为null</p>
<p>如果也为null，那么条件正确，返回true，但由于为!，所以实际为false，不执行判断内的语句</p>
<p>而如果o2不为null，那么则返回false，进而转变为true，执行语句<code>return false</code>，这就跟我们的目的相一致（因为一个为null一个不为null）</p>
<p>而如果o1不为null，那么就执行<code>o1.equals(o2)</code></p>
<p>如果两者相等，那么则返回true，转换为false，不执行语句</p>
<p>可以看到，无论怎么样，这里都会正确的比较</p>
<p>那么问题来了，为什么不直接用<code>equals()</code></p>
<p>我们不妨看看这里（指的是o1.equals(o2)）的equals源码是怎么写的：</p>
<blockquote>
<p>这里的equals来自这个文件 -&gt; Object.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清楚地看到，这里并没有对null进行处理</p>
<p>不进行处理会导致什么后果呢？很明显，那就是：<strong>NullPointerException</strong></p>
<p><strong>hashcode()</strong></p>
<p>接下来是hashcode方法</p>
<p>这个方法没有参数，主要的使用用途为计算指定元素的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;Hello！&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该元素的哈希值%s&quot;</span>,arrayList.getFirst().hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该元素的哈希值：-2137002865</span></span><br></pre></td></tr></table></figure>

<p>一个比较常见的用法是通过比较生成的哈希值来判断两个值是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;Hello！&quot;</span>);</span><br><span class="line">arrayList1.add(<span class="string">&quot;Hello！&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayListHashCode</span> <span class="operator">=</span> arrayList.getFirst().hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayList1HashCode</span> <span class="operator">=</span> arrayList1.getFirst().hashCode();</span><br><span class="line">System.out.printf(<span class="string">&quot;这两个元素是否相等：%s&quot;</span>, arrayList1HashCode == arrayListHashCode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 这两个元素是否相等：true</span></span><br></pre></td></tr></table></figure>

<p>不过需要说明的一点是，上面的比较方法是有点问题的</p>
<p>在Java中经常是有些元素的哈希值是相同的，比如<strong>通话</strong>和<strong>重地</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;通话&quot;</span>);</span><br><span class="line">arrayList1.add(<span class="string">&quot;重地&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayListHashCode</span> <span class="operator">=</span> arrayList.getFirst().hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayList1HashCode</span> <span class="operator">=</span> arrayList1.getFirst().hashCode();</span><br><span class="line">System.out.printf(<span class="string">&quot;这两个元素是否相等：%s&quot;</span>, arrayList1HashCode == arrayListHashCode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 这两个元素是否相等：true</span></span><br></pre></td></tr></table></figure>

<p>那么要怎么解决这个问题呢？其实很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(<span class="string">&quot;通话&quot;</span>);</span><br><span class="line">arrayList1.add(<span class="string">&quot;重地&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayListHashCode</span> <span class="operator">=</span> arrayList.getFirst().hashCode();</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayList1HashCode</span> <span class="operator">=</span> arrayList1.getFirst().hashCode();</span><br><span class="line">System.out.printf(<span class="string">&quot;这两个元素是否相等：%s&quot;</span>, arrayList1HashCode == arrayListHashCode &amp;&amp; arrayList1.getFirst().equals(arrayList.getFirst()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 这两个元素是否相等：false</span></span><br></pre></td></tr></table></figure>

<p>通过先比较哈希值再比较字符串是否相等，这样便可以解决<strong>哈希碰撞</strong>的问题</p>
<blockquote>
<p>更多的内容可以参考后面HashSet的 补充点：底层实现</p>
</blockquote>
<p><strong>clone()</strong><br>接下来讲讲这个方法</p>
<p>在讲这个方法的具体用法之前，需要先补充一下<code>浅拷贝</code>和<code>深拷贝</code>的内容</p>
<h5 id="补充点：浅拷贝与深拷贝"><a href="#补充点：浅拷贝与深拷贝" class="headerlink" title="补充点：浅拷贝与深拷贝"></a>补充点：浅拷贝与深拷贝</h5><blockquote>
<p>此处可能会使用到C里面的指针来辅助理解<br>首先是浅拷贝</p>
</blockquote>
<p>假设现在有一个数组，你使用浅拷贝拷贝这个数组，那么拷贝后的新数组中是原来的元素吗</p>
<p>虽然说表面上是一样的，但实际上是不一致的</p>
<p>新数组拷贝的是老数组中的对各个元素的引用，这意味了什么？</p>
<p>意味着假设你修改了老数组中引用对应的元素，那么拷贝后的数组也会被修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;StringBuffer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span> + i));</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;StringBuffer&gt; arrayListClone = (ArrayList&lt;StringBuffer&gt;) arrayList.clone();</span><br><span class="line">arrayList.get(<span class="number">2</span>).append(<span class="number">3</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：[Hello0, Hello1, Hello23, Hello3, Hello4]</span></span><br><span class="line"><span class="comment">// 复制后的数组：[Hello0, Hello1, Hello23, Hello3, Hello4]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，即使是先复制再修改也没办法改变，因为实际上是复制引用而不是直接复制对应的元素</p>
<p>这里可能有人就要说了：诶，那为什么我的结果跟这里说的不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;String&gt; arrayListClone = (ArrayList&lt;String&gt;) arrayList.clone();</span><br><span class="line">arrayList.add(<span class="number">2</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：[Hello0, Hello1, 3, Hello2, Hello3, Hello4]</span></span><br><span class="line"><span class="comment">// 复制后的数组：[Hello0, Hello1, Hello2, Hello3, Hello4]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里即使修改了原数组复制后的数组依旧没有改变</p>
<p>难道是出问题了吗？<strong>不是</strong>，其实这里跟所选的类型有关</p>
<p>我们可以看到，在第一个例子中我们选择的类型为：<code>StringBuffer</code></p>
<p>而第二个例子中我们选择的是<code>String</code></p>
<p>诶，那这俩有什么区别呢？</p>
<p>很简单，一个可变，一个不可变</p>
<p>说白了就是<code>StringBuffer</code>是可变的，所以当原数组变了复制的数组也就变了</p>
<p>而<code>String</code>是不可变的，该怎么样就怎么样，不管是不是被修改的</p>
<hr>
<p>那么此处来通过C的例子来简单说明一下浅拷贝</p>
<p>假设我们有一个装满指针的数组，浅拷贝就是复制这个数组</p>
<p>这个数组有什么呢？有指针，指向不同的内存地址</p>
<p>那么，假设我现在修改原数组中某一个指针指向的一个元素，</p>
<p>那么这个指针指向的就是这个新的元素</p>
<p>由于复制的只是指针，所以复制的数组也会指向这个元素（由于内存地址不变，这个指针指向的还是那个地址）</p>
<p>那么要怎么解决这个问题呢？其实很简单，使用<strong>深拷贝</strong>即可</p>
<p>诶，那深拷贝又是复制什么呢？</p>
<p>准确来讲，深拷贝其实是创建了一个新的对象，然后递归复制所有原先数组引用的底层对象</p>
<p>说白了就是直接复制元素而不是复制引用</p>
<blockquote>
<p>不过有一说一，之前举的String的例子其实就有点深拷贝的意味了<br><del>不过这玩意由于是误打误撞实现了，所以不能这么记</del></p>
</blockquote>
<hr>
<p>在讲完浅拷贝和深拷贝之后，就要正式介绍有关<code>clone()</code>方法的内容了</p>
<p>首先这个方法并没有任何的参数：<code>Object clone()</code></p>
<p>并且在使用的时候还要记得<strong>显式类型转换</strong>，否则会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;String&gt; arrayListClone = arrayList.clone();</span><br><span class="line">arrayList.add(<span class="number">2</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// java: 不兼容的类型: java.lang.Object无法转换为java.util.ArrayList&lt;java.lang.String&gt;</span></span><br></pre></td></tr></table></figure>

<p>正确的写法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;String&gt; arrayListClone = (ArrayList&lt;String&gt;) arrayList.clone();</span><br><span class="line">arrayList.add(<span class="number">2</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：[Hello0, Hello1, 3, Hello2, Hello3, Hello4]</span></span><br><span class="line"><span class="comment">// 复制后的数组：[Hello0, Hello1, Hello2, Hello3, Hello4]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里就正常运行了</p>
<h5 id="补充点：为什么会有警告"><a href="#补充点：为什么会有警告" class="headerlink" title="补充点：为什么会有警告"></a>补充点：为什么会有警告</h5><p>如果你使用IntelliJ IDEA并且打出上面那段代码，那么你会发现编译器会给你一个警告：<br><code>未检查的转换: &#39;java.lang.Object&#39; 转换为 &#39;java.util.ArrayList&lt;java.lang.String&gt;&#39;</code></p>
<p>那么这是什么意思呢？简单来说就是编译器没办法在运行的时候判断其正确性</p>
<p>虽然说ArrayList重写了<code>clone()</code>方法，但为了兼容性，返回类型依旧为<code>Object</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自ArrayList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么有什么问题呢？</p>
<p>为了正常运行，我们在使用<code>clone()</code>的时候是有进行显式类型转换的</p>
<p>但是Java的泛型在运行时会被擦除（Type Erasure）</p>
<p>虽然JVM知道这玩意是ArrayList，但是不知道是哪个类型</p>
<p>这就导致了无法确定这玩意是不是真的是装着<code>String</code>的ArrayList</p>
<p>那要怎么办呢？其实很简单：那就是换一种复制方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;StringBuffer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span> + i));</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;StringBuffer&gt; arrayListClone = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arrayList);</span><br><span class="line">arrayList.get(<span class="number">2</span>).append(<span class="number">3</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组：[Hello0, Hello1, Hello23, Hello3, Hello4]</span></span><br><span class="line"><span class="comment">// 复制后的数组：[Hello0, Hello1, Hello23, Hello3, Hello4]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用了<code>new ArrayList&lt;&gt;(arrayList)</code>，这种方法就不会抛出警告了</p>
<blockquote>
<p>顺带一提，这种方式也是浅拷贝（看输出也可以明白）</p>
</blockquote>
<p>不过如果你真的很想使用原先的<code>clone()</code>方法，但不想看到警告，那么可以在这个语句的上一行加上这么一句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;StringBuffer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span> + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">ArrayList&lt;StringBuffer&gt; arrayListClone = (ArrayList&lt;StringBuffer&gt;) arrayList.clone();</span><br><span class="line">arrayList.get(<span class="number">2</span>).append(<span class="number">3</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组：%s\n&quot;</span>,arrayList);</span><br><span class="line">System.out.printf(<span class="string">&quot;复制后的数组：%s\n&quot;</span>,arrayListClone);</span><br></pre></td></tr></table></figure>

<p>这里加上了<code>@SuppressWarnings(&quot;unchecked&quot;)</code>语句，成功消除了警告</p>
<p><strong>toString()</strong><br>接下来讲讲toString方法，这个方法有点类似Python中的<code>__str__</code>魔术方法</p>
<p>一般而言，这个方法会被重写成想要的方法来方便输出对应的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String whatName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Aclass</span><span class="params">(String whatName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.whatName = whatName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;这个对象的名字是：%s&quot;</span>,whatName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Aclass</span> <span class="variable">aclass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aclass</span>(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        System.out.println(aclass.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 这个对象的名字是：测试</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们这里重写了这个方法：<code>toString()</code>，是的他可以按我们规定的输出方式输出</p>
<p>那么在ArrayList里面又是如何的呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;使用toString方法: %s&quot;</span>, arrayList.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用toString方法: [hello0, hello1, hello2, hello3, hello4]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的结果实际上和直接使用该集合作为参数是一致的：</p>
<p>那么具体又是如何的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   Iterator&lt;E&gt; it = iterator();</span><br><span class="line">   <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">   sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">      sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">      <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">      sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码来自：<code>AbstractCollection.java</code>，ArrayList中toString方法的实现就是来自这里</p>
<p>此处的基本原理是：如果一开始无法用迭代器返回下一个元素，则直接返回：<code>[]</code></p>
<blockquote>
<p>这里其实也就是在处理 null</p>
</blockquote>
<p>如果不属于null，那么则处理另一种情况：</p>
<p>首先第一步：是往StringBuilder里面添加：<code>[</code>来模拟数组的输出</p>
<p>之后开始一个一个遍历元素</p>
<p>此处用到了一些很巧妙的点，注意看这里的for循环三个表达式都是没有的，唯一的退出条件就是迭代器无法返回下一个元素（也就是结束的情况）</p>
<p>这样的好处是可以完全遍历这个集合</p>
<p>此处是先检测是否集合遍历结束才来加上逗号和空格的</p>
<p>ArrayList也可以重写这个方法，与之前演示的例子没有太大差异，这里便不多阐述</p>
<p><strong>stream()</strong><br>接下来是stream()方法，这个方法下面有高达35个方法，这里将依次介绍</p>
<p>但是在这之前我们需要介绍一下stream是来干什么的</p>
<p>首先简单介绍一下，这个方法正如他的名字一样：可以进行流式处理</p>
<p>相当于说把这玩意通过一个流水线一点一点进行处理，最后输出想要的结果</p>
<p>但在正式介绍这个方法之前，我们需要先介绍一下里面的一些小概念：</p>
<p>首先是<strong>中间操作</strong>和<strong>终端操作</strong></p>
<p>中间操作的意思是这个操作可以连接前后的方法，构建一条完整流，而终端操作意味着这个方法作为结尾的方法，只能在结尾使用（因为这种方法无法继续连接其他方法）</p>
<p>那么有什么方法可以判断是哪一种操作呢？其实很简单，只需要看这个操作的返回值即可</p>
<p>一般而言，如果返回值为<code>stream</code>的话，这个方法便为中间操作（例如<code>filter()</code>，<code>distinct()</code>等）</p>
<p>如果返回值不为<code>stream</code>，而是为其他的话，那么这个方法便为终端操作</p>
<hr>
<p>这里再讲深入一点</p>
<p>中间操作为惰性操作，也就是不会立刻执行</p>
<p>而终端操作是会立刻执行的，进而激活整个流</p>
<p>上文也提及到，终端操作属于结尾的操作，所以只能有一个</p>
<p>而中间操作属于整个流里面的一个组成部分，所以是可以有多个的</p>
<p><strong>filter()</strong><br>此方法返回类型为<code>stream</code>，为中间操作</p>
<p>filter这个方法的作用是作为一个筛子筛选出对应的元素</p>
<p>比如说我想要筛选出所有第一个字母为<code>a</code>的元素，那么可以这么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;avocado&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .filter(a -&gt; a.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// avocado</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在上面这个例子中我们通过<code>filter</code>方法成功筛选出所有以字母a开头的元素</p>
<p>虽然这玩意可以筛选指定元素，但是并不会对原来集合进行修改</p>
<p><strong>distinct()</strong><br>此方法返回类型为<code>stream</code>，为中间操作</p>
<p>接下来介绍一下distinct()这个方法</p>
<p>这个方法的作用是去除所有的重复元素，只保留一个</p>
<p>效果有点像是Set接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>从上面便可以看出，在通过<code>distinct()</code>处理之后，输出的元素便没有任何重复的内容了</p>
<p>我们可以利用这个方法去重</p>
<p>这个方法的底层实现也是很有意思的，其去重的原理跟Set接口其实差不多，通过使用<code>equals()</code>和<code>hashcode()</code>方法来实现去重</p>
<p><strong>sorted()</strong><br>此方法返回类型为<code>stream</code>，故为中间操作</p>
<p>接下来是sorted()，这个方法的作用是对当前流进行排序</p>
<p>有点类似TreeMap或者TreeSet</p>
<p>这里我们依旧以上文<code>distinct()</code>中的例子作为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .sorted()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在使用了sorted()之后，输出的结果便不是之前的乱序了，而是以正序排列</p>
<p>既然这个可以实现排序，那么自然也可以定义排序，相关的内容可以参照TreeSet的<code>补充点：定义排序规则</code></p>
<p>这里简单举几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;coconut&quot;</span>, <span class="string">&quot;avocado&quot;</span>, <span class="string">&quot;durian&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .sorted(Comparator.comparing(String::length)</span><br><span class="line">               .thenComparing(Comparator.naturalOrder()))</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// cherry</span></span><br><span class="line"><span class="comment">// durian</span></span><br><span class="line"><span class="comment">// apricot</span></span><br><span class="line"><span class="comment">// avocado</span></span><br><span class="line"><span class="comment">// coconut</span></span><br></pre></td></tr></table></figure>
<p>这里的排序规则是这样的：<br><code>Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder())</code></p>
<p>那么这个是什么意思的，简单来说就是先按字符串长度排序（String::length）</p>
<p>然后再以自然排序的方式排序（Comparator.naturalOrder()）</p>
<h5 id="补充点：有关如何排序"><a href="#补充点：有关如何排序" class="headerlink" title="补充点：有关如何排序"></a>补充点：有关如何排序</h5><p>sorted()的底层使用了<code>双轴快排（Dual-Pivot Quicksort）</code></p>
<p>这个东西是传统快排的一个改进版本，使用了三个分区，而传统快排只用了两个分区</p>
<p>使用双轴快排的好处是减小<strong>常数因子</strong>（两种快排的时间复杂度都是O(n log n)）</p>
<p>通过减少常数因子来得到更好的效率，这也就是为什么选择双轴快排的原因</p>
<p><strong>peek()</strong><br>此方法返回值为stream，故为中间操作</p>
<p>接下来介绍peek()这个方法</p>
<p>这个方法很简单，就是在流的指定的地方来进行一次操作（这个操作不会产生影响）</p>
<p>一般而言，这个东西会用于日志这一类操作里面</p>
<p>不过这里就简单的演示一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .peek(a -&gt; System.out.printf(<span class="string">&quot;当前数组元素有：%s%n&quot;</span>, a))</span><br><span class="line">         .sorted(Comparator.comparing(String::length)</span><br><span class="line">               .thenComparing(Comparator.naturalOrder()))</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前数组元素有：apple</span></span><br><span class="line"><span class="comment">// 当前数组元素有：apricot</span></span><br><span class="line"><span class="comment">// 当前数组元素有：banana</span></span><br><span class="line"><span class="comment">// 当前数组元素有：cherry</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// cherry</span></span><br><span class="line"><span class="comment">// apricot</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里插入了一个打印的操作</p>
<p>需要注意的一个点是，如果没有任何的终端操作，那么是不会执行peek的操作的</p>
<p><strong>limit()</strong><br>该方法返回类型为stream，故为中间操作</p>
<p>接下来介绍一下这个方法</p>
<p>这个方法的作用是截取原流中的前n个元素并返回作为新的流</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .distinct()</span><br><span class="line">         .limit(<span class="number">2</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// apricot</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出部分就只有两个了</p>
<p>那么这也引出了一个问题，这玩意如果大于小于等于原流长度会怎么样呢？</p>
<p>简单概括一下：</p>
<p>如果原流小于截取长度，那么返回原流</p>
<p>如果原流等于截取长度，那么返回原流</p>
<p>如果原流大于截取长度，那么返回截取的长度</p>
<h5 id="扩展：短路操作（Short-Circuiting-Operation）"><a href="#扩展：短路操作（Short-Circuiting-Operation）" class="headerlink" title="扩展：短路操作（Short-Circuiting Operation）"></a>扩展：短路操作（Short-Circuiting Operation）</h5><p>这里是一个用于扩展的用法，主要说明limit()方法的实际使用</p>
<hr>
<p>不过由于此处还需一些终端操作，便不多扩展</p>
<p>假设你有一个很长很长的数组，你需要选取这个数组里面的一些元素，于是你打算遍历这个数组来寻找想要的元素</p>
<p>所以你向机器发送了“遍历这个数组”的指令</p>
<p>过了一会后，机器返回给你想要的元素，但是你发现了一个点，所需的元素其实很快就找到的，但是由于要遍历整个数组，所以花费时间和资源很多</p>
<p>那么要怎么解决这个问题呢？其实很简单，只需要使用<strong>短路操作</strong>即可</p>
<p>所谓短路操作，指的是在实现某个条件后就直接中断（类似短路）</p>
<p>假设我们把这个数组变成无限长度，此时我们想要前5个偶数</p>
<p>假设我们是通过遍历的方法，那么无论如何都得不到输出，因为中间操作为惰性方法，必须有终端操作才行，而数组是无限长的，所以永远达不到</p>
<p>但是如果我们选择短路操作，便可以达到这个目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">         .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">         .limit(<span class="number">5</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里在一个无限数组里面成功输出了前五个偶数</p>
<p><strong>skip()</strong><br>该方法返回类型为<code>stream</code>，故为中间操作</p>
<p>接下来介绍一下skip()方法，这个方法比较简单，具体的功能为跳过指定的n个元素（或者说从第n + 1个元素开始）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .skip(<span class="number">2</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// cherry</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的内容是从第三项开始的，也就是跳过了两项</p>
<p>不过需要提醒的一点是，如果这个是有序流（例如这里的ArrayList），那么则会正常的跳过前n项</p>
<p>但如果是无序流（例如Set接口里面的集合），由于不知道顺序是什么，所以跳过的元素是随机的</p>
<p>这里同样引出一个问题：如果数组长度大于等于小于原流会怎么样</p>
<p>简单概括如下</p>
<p>如果大于原流，那么什么都不返回</p>
<p>如果等于原流，也是什么都不返回</p>
<p>如果小于原流，那么按正常结果返回</p>
<p>除此之外，如果n小于等于0，那么会抛出这个报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] numbersList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbersList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .skip(-<span class="number">1</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<hr>
<p>在实际的应用中，你可以利用这个方法实现翻页效果</p>
<blockquote>
<p>此处仅限小数据！大规模数据这里花费时间为n，太慢了！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apricot&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;coconut&quot;</span>, <span class="string">&quot;avocado&quot;</span>, <span class="string">&quot;durian&quot;</span>, <span class="string">&quot;damson&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">int</span> <span class="variable">eachPage</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">startPage</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .skip(eachPage * (startPage - <span class="number">1</span>))</span><br><span class="line">         .limit(eachPage)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// coconut</span></span><br><span class="line"><span class="comment">// avocado</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的便是第三页的内容</p>
<p>每页有两个元素，从第三页开始，那么便跳过了 2 * (3 - 1) 个元素</p>
<p><strong>takeWhile()</strong><br>该方法返回的类型为stream，故为中间操作</p>
<p>该方法有一个可填参数，该参数用于判断</p>
<p>接下来是takeWhile方法，这个方法的作用是按顺序选取流里面的元素，直到出现不满足条件的元素，并返回新流</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cabbage&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;brush&quot;</span>, <span class="string">&quot;comb&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .takeWhile(a -&gt; a.length() &gt; <span class="number">4</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// cabbage</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里选择的标准为：<strong>若该元素长度大于4，则返回为真</strong></p>
<p>我们可以稍微模拟一下：</p>
<p>首先第一次：<code>apple</code>，长度为5，大于4，所以为真</p>
<p>第二次：<code>banana</code>，长度为6，大于4，所以为真</p>
<p>第三次：<code>cabbage</code>，长度为7，大于4，所以为真</p>
<p>第四次：<code>date</code>，长度为4，等于4，不满足条件，退出</p>
<p>可以看到，第四次条件不满足，所以直接退出了，返回的新流为一到三次的结果</p>
<p>与上文的limit一样，这个方法也可以用于短路操作</p>
<p>由于这个方法读取顺序是按顺序读取，所以如果为无序流则会随机读取</p>
<p><strong>dropWhile()</strong><br>此方法返回类型为stream，故属于中间操作</p>
<p>这个方法的作用与takeWhile差不多，主要效果与上文的takeWhile效果是相反的</p>
<p>换句话说，这个方法的作用是在判断为真时跳过，如果判断为假，则截断并选取后面所有的元素</p>
<p>我们通过一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cabbage&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;brush&quot;</span>, <span class="string">&quot;comb&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .dropWhile(a -&gt; a.length() &gt; <span class="number">4</span>)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// date</span></span><br><span class="line"><span class="comment">// brush</span></span><br><span class="line"><span class="comment">// comb</span></span><br></pre></td></tr></table></figure>
<p>通过上文我们可以知道此处在第四次的时候返回为假，所以返回的结果就是该项后面的各个元素</p>
<p><strong>forEach()</strong><br>该方法返回类型<strong>不为</strong>stream，故为终端操作</p>
<p>接下来介绍这个方法，这个方法属于终端操作，所以只能放置在最后一个位置</p>
<p>并且在上文也提及到了，<strong>每个操作流中只能有一个终端操作</strong></p>
<p>在简单介绍完终端操作之后，便开始介绍这个方法：</p>
<p>这个方法的作用是对流中的<strong>每一个元素执行指定的操作</strong></p>
<blockquote>
<p>在上文其实很多例子都使用了这个方法，但是此处还是再次举个例子来说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .takeWhile(a -&gt; a.startsWith(<span class="string">&quot;ba&quot;</span>))</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// banana</span></span><br><span class="line"><span class="comment">// bag</span></span><br><span class="line"><span class="comment">// ball</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>forEach</code>语句对所有的元素都使用了<code>System.out::println</code>，也就是将流里面的每一个元素都打印出来</p>
<p><strong>forEachOrdered()</strong><br>接下来的这个方法与forEach方法是一致的，但是在细节上有些不同，此处重点讲不同，具体的使用方法可以参照<code>forEach()</code></p>
<p>首先这个方法的一大特点就是<strong>必定按顺序输出</strong></p>
<p>诶，这里可能就有人有疑惑了，什么叫做必定按顺序输出呢？</p>
<p>要讲这个的话就得简单引入<code>parallelStream()</code>，<strong>并行流</strong></p>
<p>这个流在处理的时候会使用到多线程，在合并的时候可能出现一些合并上的问题，比如说使用<code>forEach()</code>时，如果线程2比线程1先完成，那么会直接执行，不等线程1，举个例子：</p>
<p>假设被操作的流中元素为A B C</p>
<p>其中A耗时最大，C耗时最少</p>
<p>此时若使用<code>parallelStream().forEach()</code>的话，那么会导致耗时较少的C先输出</p>
<p>而耗时较长的A反而慢输出</p>
<p>这很明显不符合我们的预期</p>
<p>所以便有了这个方法来强制按顺序输出</p>
<p>但这样做是有代价的，<code>forEachOrdered()</code>的性能是不如<code>forEach()</code>的，如果你在使用并行流的时候不在意输出的顺序，那么请使用<code>forEach()</code>来提高性能</p>
<h5 id="扩展：为何有序"><a href="#扩展：为何有序" class="headerlink" title="扩展：为何有序"></a>扩展：为何有序</h5><p>接下来简单讲一讲这个方法是如何实现有序的：</p>
<p>首先当你在一个并行流里面调用这个方法的时候，这个流会被分割成好几块（forEach也会分割成好几块，但是后面的处理是不一样的）</p>
<p>在分割完之后便分别开始处理，在开始处理的时候会保留这个元素原先在哪个位置</p>
<p>系统会自动创建一个队列用于缓存，每当有一个处理完之后，不会直接执行，而是把这些放到缓存区里面去</p>
<p>最后，便会有一个专门的线程（不一定是新的，有可能是主线程）来按照顺序取出元素并对其使用<code>action</code></p>
<p>也正因如此，<code>forEachOrdered</code>比<code>forEach</code>多了一系列的操作，所以会更费性能</p>
<p><strong>toArray()</strong><br>这个方法返回类型为Object，所以为<strong>终端操作</strong></p>
<p>接下来简单介绍这个方法，这个方法很简单，作用就是将当前的流转换为数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">String[] newList =  arrayList.stream()</span><br><span class="line">         .takeWhile(a -&gt; a.startsWith(<span class="string">&quot;ba&quot;</span>))</span><br><span class="line">         .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后的数组为：%s&quot;</span>, Arrays.toString(newList));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后的数组为：[banana, bag, ball]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里将用takeWhile筛选后的流转换一个新的数组</p>
<p>这里括号内的参数实际为：<code>类型[]::new</code>，是一种方法引用，不过这里不多阐述</p>
<p>注意，如果没有在toArray的括号里面添加说明想要转换成什么类型的话，会默认转换成Object类型，这就导致了想要使用的时候必须进行强制类型转换</p>
<h5 id="补充点：有何意义"><a href="#补充点：有何意义" class="headerlink" title="补充点：有何意义"></a>补充点：有何意义</h5><p>在上文的例子中可能有人看到了这一点：<code>Arrays.toString(newList)</code></p>
<p>很明显，这里是重新转换为字符串了</p>
<p>可能就有人想问这样有什么意义，但事实上这里只是为了简单演示才使用这个转换的</p>
<p>实际上，使用toArray转换为数组可以让我们使用流中的方法简化一系列操作</p>
<p>假设我们想要筛选整个数组，那么原先的做法是使用for语句加上判断来查找，但是如果使用流只需要使用takeWhile就可以了</p>
<p>这也就是为什么要使用toArray的原因：<strong>简化操作</strong></p>
<p><strong>min() &amp; max()</strong><br>这两个操作都属于终端操作，并且由于效果是很接近的，所以放到一起讲</p>
<p>这个方法其实很简单，就是通过括号内的比较规则来比较出最小 &#x2F; 最大的那个元素</p>
<p>举个很简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line">Optional&lt;String&gt; newItem = arrayList.stream()</span><br><span class="line">         .takeWhile(a -&gt; a.startsWith(<span class="string">&quot;ba&quot;</span>))</span><br><span class="line">         .min(Comparator.comparing(String::length));</span><br><span class="line">newItem.ifPresent(a -&gt; System.out.printf(<span class="string">&quot;最小长度元素为：%s&quot;</span>, a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 最小长度元素为：bag</span></span><br></pre></td></tr></table></figure>
<p>max方法同理，返回的是最大的</p>
<p>此处使用到了两个新东西(<code>Optional</code>和<code>ifPresent</code>)，这里只是为了介绍min的使用效果，所以不多介绍</p>
<p>上面的这个代码排序的规则是根据元素字符串的长度来比较的（String::length），此处使用了方法引用</p>
<p><strong>count()</strong><br>该方法返回类型为long，故为终端操作</p>
<p>接下来介绍count()</p>
<p>count()这个方法十分简单，作用为计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">long</span> <span class="variable">howMany</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .takeWhile(a -&gt; a.startsWith(<span class="string">&quot;ba&quot;</span>))</span><br><span class="line">         .count();</span><br><span class="line">System.out.printf(<span class="string">&quot;满足条件的个数：%s&quot;</span>, howMany);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 满足条件的个数：3</span></span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，这个方法返回的类型为long，<strong>不是int！！！</strong></p>
<p>这个方法有个很有意思的点，如果这个流来自一个大小已知的源，并且没有执行任何会修改的操作（比如filter或者takeWhile），那么会直接返回底层的size，时间复杂度为<code>O(1)</code></p>
<p>但如果有的话则需要遍历整个数组，时间复杂度会变为<code>O(n)</code></p>
<p><strong>anyMatch()</strong><br>该方法返回类型boolean，所以为终端操作</p>
<p>接下来是这个方法，这个方法的作用是检查是否有元素满足括号内的条件，如果有的话就返回true，如果没有就返回为false</p>
<p>接下来给个具体例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .peek(a -&gt; System.out.printf(<span class="string">&quot;判断元素：%s%n&quot;</span>, a))</span><br><span class="line">         .anyMatch(a -&gt; !a.startsWith(<span class="string">&quot;ba&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;数组里面是否有不符合规则的：%s&quot;</span>, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 判断元素：banana</span></span><br><span class="line"><span class="comment">// 判断元素：bag</span></span><br><span class="line"><span class="comment">// 判断元素：ball</span></span><br><span class="line"><span class="comment">// 判断元素：comb</span></span><br><span class="line"><span class="comment">// 数组里面是否有不符合规则的：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法实现了一次<strong>短路操作</strong>，在判断满足条件的元素后直接返回<code>true</code>，这样就可以不用遍历整个数组</p>
<h5 id="补充点：关于空流"><a href="#补充点：关于空流" class="headerlink" title="补充点：关于空流"></a>补充点：关于空流</h5><p>现在假设这个流里面是没有任何东西的（也就是空流），这时对这个流进行操作怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .peek(a -&gt; System.out.printf(<span class="string">&quot;判断元素：%s%n&quot;</span>, a))</span><br><span class="line">         .anyMatch(a -&gt; !a.startsWith(<span class="string">&quot;ba&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;数组里面是否有不符合规则的：%s&quot;</span>, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 数组里面是否有不符合规则的：false</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里并没有执行peek的操作，而是直接返回false</p>
<p><strong>allMatch()</strong><br>该方法依旧为终端操作</p>
<p>这个方法与上文的<code>anyMatch()</code>效果差不多，一个是找到一个就直接输出true，一个是要所有都满足才会输出true</p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">&quot;ba&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isContains</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .allMatch(s -&gt; s.startsWith(<span class="string">&quot;ba&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;是否全部为ba开头：%s&quot;</span>, isContains);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 是否全部为ba开头：false</span></span><br></pre></td></tr></table></figure>
<p>在上面这里例子中，我们判断该集合是否全部以<code>ba</code>作为开头，但是该集合中含有不以<code>ba</code>开头的元素，所以返回了<code>false</code></p>
<h5 id="补充点：关于空流-1"><a href="#补充点：关于空流-1" class="headerlink" title="补充点：关于空流"></a>补充点：关于空流</h5><p>在上文的<code>anyMatch</code>中，对空流执行操作会返回false，那么对空流使用allMatch()会怎么样呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .peek(a -&gt; System.out.printf(<span class="string">&quot;判断元素：%s%n&quot;</span>, a))</span><br><span class="line">         .allMatch(a -&gt; !a.startsWith(<span class="string">&quot;ba&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;数组里面是否有不符合规则的：%s&quot;</span>, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 数组里面是否有不符合规则的：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里返回的是true，与上面的anyMatch是不同的</p>
<p><strong>noneMatch()</strong><br>该方法依旧为终端操作</p>
<p>这个方法与上文的两个方法效果差不多的，主要的作用依旧为判断，返回类型依旧为boolean</p>
<p>具体的用法是，如果不满足noneMatch条件内，那么返回true：</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">&quot;ba&quot;</span>, <span class="string">&quot;bag&quot;</span>, <span class="string">&quot;ball&quot;</span>, <span class="string">&quot;comb&quot;</span>, <span class="string">&quot;band&quot;</span>, <span class="string">&quot;bath&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isContains</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .noneMatch(s -&gt; s.startsWith(<span class="string">&quot;s&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;是否不存在以s为开头：%s&quot;</span>, isContains);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 是否存在不以ba为开头：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出为true，这说明没有以s开头的元素</p>
<h5 id="补充点：关于空流-2"><a href="#补充点：关于空流-2" class="headerlink" title="补充点：关于空流"></a>补充点：关于空流</h5><p>这里补充一下如果是空流的是时候会出现什么情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] itemList = &#123;&#125;;</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(itemList));</span><br><span class="line"><span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .peek(a -&gt; System.out.printf(<span class="string">&quot;判断元素：%s%n&quot;</span>, a))</span><br><span class="line">         .noneMatch(a -&gt; a.startsWith(<span class="string">&quot;ba&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;数组里面是否有不符合规则的：%s&quot;</span>, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 数组里面是否有不符合规则的：true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的结果为true，与上文的allMatch是一致的</p>
<p><strong>findFirst()</strong><br>这个方法为终端操作</p>
<p>接下来介绍findFirst方法，这个方法的作用是返回流里面第一个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;bath&quot;</span>, <span class="string">&quot;breath&quot;</span>, <span class="string">&quot;basic&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;application&quot;</span>, <span class="string">&quot;agreement&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line">Optional&lt;String&gt; find = arrayList.stream()</span><br><span class="line">         .filter(s -&gt; s.startsWith(<span class="string">&quot;br&quot;</span>))</span><br><span class="line">         .findFirst();</span><br><span class="line">find.ifPresent(a -&gt; System.out.printf(<span class="string">&quot;符合条件的第一个值为：%s&quot;</span>, a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 符合条件的第一个值为：breath</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出了筛选后的第一个元素</p>
<p>由于返回类型为Optional，所以不用担心返回为空的情况</p>
<p><strong>findAny()</strong><br>该方法为终端操作</p>
<p>接下来介绍这个方法，这个方法的作用与上一个方法<code>findFirst()</code>是差不多的，主要的区别是在选取方法上</p>
<p>上一个方法返回的是找到的第一个满足条件的元素，而这个方法返回的虽然也是第一个满足条件的元素，但是是<strong>最先被处理的第一个元素</strong></p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;bath&quot;</span>, <span class="string">&quot;breath&quot;</span>, <span class="string">&quot;basic&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;application&quot;</span>, <span class="string">&quot;agreement&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line">Optional&lt;String&gt; find = arrayList.parallelStream()</span><br><span class="line">         .filter(s -&gt; s.startsWith(<span class="string">&quot;ba&quot;</span>))</span><br><span class="line">         .findAny();</span><br><span class="line">find.ifPresent(a -&gt; System.out.printf(<span class="string">&quot;符合条件的第一个值为：%s&quot;</span>, a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 符合条件的第一个值为：basic</span></span><br><span class="line"><span class="comment">// （这里输出是随机的，看哪个线程先处理完）</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的结果十分出人意料</p>
<p>如果这里使用的是findFirst，那么返回的值将会是找到的第一个满足条件的元素，也就是<code>bath</code></p>
<p>诶，可能就有人会发现了，为什么自己测试的时候结果是相同的？其实很简单，这个方法只有在**并行流（parallelStream）**才有效果</p>
<p>如果是在普通的流（顺序流stream）中，则会像正常一样输出</p>
<p>为什么会这样呢？因为stream是一个有序的流，所有的元素会按照顺序处理，findAny虽然是输出第一个符合条件的处理元素，但由于顺序流是按顺序处理的，根本不会出现不按顺序的情况，所以<code>stream.findAny()</code>的效果其实与<code>stream.findFirst()</code>的效果是一样的</p>
<p>而并行流就不一样了，这个流会把要处理的集合拆分成几分，分给一些线程处理，输出的内容纯粹看谁先处理完，这就导致输出完全随机，<code>findAny()</code>也就会输出最先处理的元素</p>
<p><strong>toList()</strong><br>这个方法为终端操作</p>
<p>接下来介绍这个方法，这个方法的作用很简单，将这个流打包为一个集合，之后返回给变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">15</span>, <span class="number">73</span>, <span class="number">128</span>, <span class="number">4</span>, <span class="number">196</span>, <span class="number">88</span>, <span class="number">51</span>, <span class="number">142</span>);</span><br><span class="line">List&lt;Integer&gt; num = lst.stream()</span><br><span class="line">         .filter(s -&gt; s % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;集合中满足条件的元素有：%s%n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 集合中满足条件的元素有：[15, 51]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出的结果是一个集合，这个集合打包了满足条件的元素</p>
<p>此处返回的集合是<strong>不可变对象</strong>，所以<strong>不可以使用任何修改集合的方法尝试修改这个集合</strong>，比如说add()，remove()</p>
<p>如果试图修改，则会抛出报错<code>UnsupportedOperationException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">15</span>, <span class="number">73</span>, <span class="number">128</span>, <span class="number">4</span>, <span class="number">196</span>, <span class="number">88</span>, <span class="number">51</span>, <span class="number">142</span>);</span><br><span class="line">List&lt;Integer&gt; num = lst.stream()</span><br><span class="line">         .filter(s -&gt; s % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;集合中满足条件的元素有：%s%n&quot;</span>, num);</span><br><span class="line">num.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 集合中满足条件的元素有：[15, 51]</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<h5 id="补充点：为什么这里不可变"><a href="#补充点：为什么这里不可变" class="headerlink" title="补充点：为什么这里不可变"></a>补充点：为什么这里不可变</h5><p>可能有人就要问了，这里明明是<code>List接口</code>啊，为什么不可变呢？</p>
<p>其实这个问题很简单，从Java 10开始，Java引进了一些不可变集合工厂方法，而<code>toList()</code>便是其中之一</p>
<p>事实上<code>.toList()</code>返回的是<code>java.util.ImmutableCollections.ListN</code>，而这个子类直接继承自<code>AbstractImmutableList</code>，这个又继承了<code>AbstractList&lt;E&gt;</code>，进而实现了List接口</p>
<p>这个抽象类重写了一些可以修改的方法，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> UnsupportedOperationException <span class="title function_">uoe</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@jdk</span>.internal.ValueBased</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbstractImmutableCollection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; <span class="keyword">throw</span> uoe(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重写了add方法，使其从之前的往集合里面添加元素变为丢出错误<code>UnsupportedOperationException</code></p>
<p>也就是在这里实现了不可变集合</p>
<p>那么为什么要不可变呢？一方面是保证<strong>线程安全</strong>，另一方面是<strong>防止不小心被修改</strong>，最后<strong>减少内存开支</strong></p>
<p><strong>map()</strong><br>这个方法为中间操作</p>
<p>接下来介绍有关函数式编程的核心之一——map()以及有关的一系列方法</p>
<p>首先简单介绍一下<code>map()</code>，这个方法的作用是<strong>在不对原先流里面元素产生任何影响的情况下返回一个新的流</strong>（无副作用）</p>
<p>什么意思呢，简单来说就是在不对原先产生任何影响的情况下返回一个新的流</p>
<p>举一个具体的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line">List&lt;Integer&gt; find = arrayList.stream()</span><br><span class="line">         .map(n -&gt; n * n)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;新的集合为：%s%n&quot;</span>, find);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 新的集合为：[4, 9, 25, 36]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里返回了一个新的流，并且这个流的每一个元素都是由原先的流经过<code>map()</code>产生得来的</p>
<p>当然，这个简单的例子可能没办法说明什么，接下来再举一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lst = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;grape&quot;</span>);</span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line">List&lt;String&gt; find = arrayList.stream()</span><br><span class="line">         .map(n -&gt; Character.toUpperCase(n.charAt(<span class="number">0</span>)) + n.substring(<span class="number">1</span>))</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;新的集合为：%s%n&quot;</span>, find);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 新的集合为：[Apple, Banana, Grape]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用了一些操作使得每个单词的首字母大写</p>
<p>具体是什么操作呢？首先获取到该单词的首字母<code>n.charAt(0)</code>，然后将其大写<code>Character.toUpperCase()</code>，在大写后就要拼接没有大写的部分了，说的直白点就是除去首字母的部分，那么对字符串操作我们可以使用到这个方法<code>n.substring(1)</code>，这个方法去除了第一个字母，也就是首字母</p>
<p>最后将这两者拼起来皆可得到我们想要的结果</p>
<p>如果使用传统的命令式编程，则需要对每一个操作都写出来（遍历，拆分，转大写）</p>
<p>而使用函数式编程则直接对想要修改的地方直接修改即可，相对来讲会方便很多</p>
<p><strong>mapToInt() &amp; mapToLong() &amp; mapToDouble()</strong><br>这些方法均为中间操作，返回类型为IntStream等</p>
<p>接下来介绍一下mapTo系列方法，这些方法与map()其实功能上差不多，都是将流里面的一个东西转变为另一个东西</p>
<p>但是mapToInt()还多了一个转换为int类型的过程，这一细微的处理直接影响了很多操作</p>
<p>举一个例子，假设我们需要返回该流里面所有数字的平方和，那么我们可以这样干：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">numList</span> <span class="operator">=</span> lst.stream()</span><br><span class="line">         .map(n -&gt; n * n)</span><br><span class="line">         .mapToInt(Integer::intValue)</span><br><span class="line">         .sum();</span><br><span class="line">System.out.printf(<span class="string">&quot;平方后各个元素之和为：%d&quot;</span>, numList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 平方后各个元素之和为：90</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用到了<code>.mapToInt(Integer::intValue)</code>，这里的这个方法引用的作用是将Integer类型拆包为int类型</p>
<p>为什么要这么干呢？这是因为原先的map返回对象为Stream，而Stream是没有.sum这个方法的，而<code>.mapToInt(Integer::intValue)</code>将原先的流转换为<code>IntStream</code>，这个类型才有<code>.sum()</code>求和的方法</p>
<p>但是，这样做其实是有点多此一举的，事实上可以直接这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">numList</span> <span class="operator">=</span> lst.stream()</span><br><span class="line">         .mapToInt(n -&gt; n * n)</span><br><span class="line">         .sum();</span><br><span class="line">System.out.printf(<span class="string">&quot;平方后各个元素之和为：%d&quot;</span>, numList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 平方后各个元素之和为：90</span></span><br></pre></td></tr></table></figure>
<p>这样直接用<code>.mapToInt()</code>代替原先的<code>.map()</code>，简化了一步转换</p>
<p>剩下的另外两个方法也是一样的道理，转换类型存在差异而已</p>
<p><strong>flatMap()</strong><br>该方法为中间操作</p>
<p>接下来介绍一下这个方法</p>
<p>这个方法的作用是将一个嵌套流扁平化处理</p>
<p>或者更加准确的讲，<strong>是将流里面的元素映射为子流，之后拍平，合并</strong></p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;List&lt;String&gt;&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arrayList.add(List.of(<span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;strawberry&quot;</span>));</span><br><span class="line">arrayList.add(List.of(<span class="string">&quot;lemon&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;pomelo&quot;</span>));</span><br><span class="line">List&lt;String&gt; newList = arrayList.stream()</span><br><span class="line">         .flatMap(Collection::stream)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;扁平化集合后为：%s%n&quot;</span>, newList);</span><br><span class="line">System.out.printf(<span class="string">&quot;未扁平化的结果：%s%n&quot;</span>, arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 扁平化集合后为：[pear, grape, strawberry, lemon, blueberry, pomelo]</span></span><br><span class="line"><span class="comment">// 未扁平化的结果：[[pear, grape, strawberry], [lemon, blueberry, pomelo]]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，使用扁平化之后，原先的嵌套结构变成了一个单一的流，成功实现了扁平化</p>
<p>这里可能就有人要问了：“为什么要实现扁平化？”</p>
<p>其实很简单，如果不进行扁平化，那么就无法对原先里面的元素进行处理</p>
<p>因为原先的结构是一个嵌套的结构</p>
<p><strong>flatMapToInt() &amp; flatMapToLong() &amp; flatMapToDouble()</strong><br>这几个方法都是属于中间操作</p>
<p>这几个跟上文的mapToInt其实作用差不多，这里简单介绍一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = List.of(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">listSum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">         .flatMapToInt(a -&gt; IntStream.of(a * a, a * a * a))</span><br><span class="line">         .sum();</span><br><span class="line">System.out.printf(<span class="string">&quot;所有数字平方和立方后和为：%d%n&quot;</span>, listSum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 所有数字平方和立方后和为：48</span></span><br></pre></td></tr></table></figure>
<p>这里的例子将数字平方和立方，然后执行求和操作，由于这里所有类型均为int，没有执行任何装箱的操作，会更加简洁点</p>
<p>虽然说原先这样子也可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = List.of(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">listSum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">         .flatMap(a -&gt; Stream.of(a * a, a * a * a))</span><br><span class="line">         .mapToInt(Integer::intValue)</span><br><span class="line">         .sum();</span><br><span class="line">System.out.printf(<span class="string">&quot;所有数字平方和立方后和为：%d%n&quot;</span>, listSum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 所有数字平方和立方后和为：48</span></span><br></pre></td></tr></table></figure>
<p>诶，效果是一样的！但是性能上呢？由于后者需要不断装箱拆包，实际性能要弱于之前一步到位的<code>flatMapToInt()</code></p>
<p>另外的两个<code>flatMapToLong()</code>和<code>flatMapToDouble()</code>效果是一样的，只不过类型需要稍微改变一下，这里不过多提及</p>
<p><strong>mapMulti()</strong><br>该方法为中间操作</p>
<p>上文我们介绍了一个十分有用的方法，<code>flatMap()</code>，但是这个方法有一个很明显的缺点——<strong>每次使用都创建一个新的流</strong></p>
<p>这样就会导致在大数据使用时大量的性能浪费，所以我们要怎么解决这个问题呢？</p>
<p>其实很简单，可以使用这个方法：<code>mapMulti()</code></p>
<p>我们使用一下之前的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = List.of(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">listSum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">         .mapMulti((a, out) -&gt; &#123;</span><br><span class="line">            out.accept(a * a);</span><br><span class="line">            out.accept(a * a * a);</span><br><span class="line">         &#125;)</span><br><span class="line">         .mapToInt(i -&gt; (<span class="type">int</span>) i)</span><br><span class="line">         .sum();</span><br><span class="line">System.out.printf(<span class="string">&quot;所有数字平方和立方后和为：%d%n&quot;</span>, listSum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 所有数字平方和立方后和为：48</span></span><br></pre></td></tr></table></figure>

<p>可以看到，通过这个方法，我们十分简单地实现了我们想要的效果，并且在这一过程中没有创建任何的中间流，大大节省了效率</p>
<p><strong>mapMultiToInt() &amp; mapMultiToLong() &amp; mapMultiToDouble()</strong><br>这些方法都是中间操作</p>
<p>这些操作的作用跟之前的<code>mapToInt()</code>和<code>flatMapToInt()</code>效果差不多，这里直接通过例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line">arrayList.stream()</span><br><span class="line">         .mapMultiToInt((a, b) -&gt; &#123;</span><br><span class="line">            b.accept(a * a);</span><br><span class="line">            b.accept(a * a * a);</span><br><span class="line">         &#125;)</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 将每个数平方和开方得到：[4, 8, 9, 27, 16, 64, 25, 125, 36, 216]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的代码与之前的相比便显得相当简便，不用再次使用<code>mapToInt()</code>来转换其中的数</p>
<p><strong>reduce()</strong><br>这个方法为终端操作</p>
<p>接下来来介绍这个方法</p>
<p>这个方法的作用为整合整理，简单举一个例子来说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; lst = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lst);</span><br><span class="line"><span class="type">OptionalInt</span> <span class="variable">addAll</span> <span class="operator">=</span> arrayList.stream()</span><br><span class="line">         .mapMultiToInt((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; <span class="number">3</span>) &#123;</span><br><span class="line">               b.accept(a * a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               b.accept(a * a * a);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">         .reduce(Integer::sum);</span><br><span class="line">addAll.ifPresent(number -&gt; System.out.printf(<span class="string">&quot;按条件相加总和为：%d&quot;</span>, number));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 按条件相加总和为：112</span></span><br></pre></td></tr></table></figure>

<p>可以看到，此处输出了一个相应的把所有数字相加的内容，其实也就是reduce把所有的数字都整合合并</p>
<p>实际上这个用法并不局限如此，还有很多很有用的用法，但这里限于篇幅所以不多补充</p>
<p><strong>collect()</strong><br>这个方法为终端操作</p>
<p>接下来介绍一下这个方法</p>
<p>collect()的作用较多，并且该操作可以理解为Stream API的核心</p>
<p>接下来将分别对这几个方法来介绍</p>
<p>首先第一个方法为<strong>collect(toList())</strong></p>
<p>这个方法的作用实际与Java 16中出现的方法<code>.toList()</code>是一致的，相关的内容可以参照<code>.toList()</code>的内容，这里简单通过一个例子说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>, <span class="string">&quot;Ackee&quot;</span>));</span><br><span class="line">List&lt;String&gt; afterFilter = list.stream()</span><br><span class="line">         .filter(s -&gt; Character.isUpperCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后新集合为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后新集合为：[Apple, Orange, Watermelon, Ackee]</span></span><br></pre></td></tr></table></figure>
<p>我们可以与<code>.toList()</code>稍微对比一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>, <span class="string">&quot;Ackee&quot;</span>));</span><br><span class="line">List&lt;String&gt; afterFilter = list.stream()</span><br><span class="line">         .filter(s -&gt; Character.isUpperCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后新集合为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后新集合为：[Apple, Orange, Watermelon, Ackee]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的结果是完全相同的</p>
<p>从这两个方法的返回类型中可以看出，这两个方法的作用都是将流里面的元素整合到一个新的集合中并返回</p>
<hr>
<p>接下来是<strong>collect(Collectors.toSet())</strong></p>
<p>这个方法的作用是将流里面的所有元素收集起来返回一个Set类型的集合</p>
<p>从这一点上看便可以发现这个集合的特性便是不接受重复元素</p>
<p>接下来通过一个例子来说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>, <span class="string">&quot;Ackee&quot;</span>));</span><br><span class="line">Set&lt;String&gt; afterFilter = list.stream()</span><br><span class="line">         .filter(s -&gt; Character.isUpperCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">         .map(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">         .collect(Collectors.toSet());</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后新集合为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后新集合为：[A, W, O]</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里筛选后的结果并没有重复的元素</p>
<hr>
<p>接下来是<strong>collect(toMap())</strong></p>
<p>这个方法的作用是返回一个Map类型的集合，在介绍这个方法的具体使用之前，需要先对其各个参数进行介绍</p>
<p>这个方法有四个可选参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">Supplier&lt;M&gt; mapFactory)</span><br></pre></td></tr></table></figure>

<p>不过这个版本不是很常用，一般会使用三个参数的版本</p>
<blockquote>
<p>事实上可以精简为两个参数，但是这样就不安全了</p>
</blockquote>
<p>这里逐一介绍四个参数</p>
<p>首先是第一个参数：<code>Function&lt;? super T, ? extends K&gt; keyMapper</code></p>
<p>这里使用到了<code>PECS原则</code>，简单讲就是让函数可以接受更通用的输入，让输出可以返回更加具体的类型</p>
<p>不过这里不多介绍，用十分简单的话来讲，第一个参数代表这个<code>Map</code>的键</p>
<p>接下来是第二个参数：<code>Function&lt;? super T, ? extends U&gt; valueMapper</code></p>
<p>这里代表这个键对应的值</p>
<p>第三个参数是为：<code>BinaryOperator&lt;U&gt; mergeFunction</code>，需要注意的是这个参数<strong>相当重要</strong>的，用于确保不会抛出<code>IllegalStateException</code></p>
<p>为什么很重要，当使用<code>toMap()</code>的时候只有两个参数（keyMapper和valueMapper），假设现在有一个键为<code>A</code>，那么接下来又传入一个新的键<code>A</code>，由于键不可以相等，所以此时程序会抛出报错<code>IllegalStateException</code>，代表这一行为是不合法的</p>
<p>但是我们不可能说完全避免这种只有一个参数的情况，这也就是第三个参数存在的意义：合理处理重复的键</p>
<blockquote>
<p>例子会在介绍完四个参数后提供</p>
</blockquote>
<p>那么接下来是第四个参数<code>Supplier&lt;M&gt; mapFactory)</code></p>
<p>这个参数的作用是规定返回的Map是什么类型，一般默认为<code>HashMap</code></p>
<p>那么在介绍完这四个参数后，就可以用一个实际的例子来说明了</p>
<blockquote>
<p>返回一个map，使得其键为这个单词的第一个字母，且单词为首字母大写，若键重复则选择最后出现一个</p>
</blockquote>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Ackee&quot;</span>, <span class="string">&quot;acerola&quot;</span>, <span class="string">&quot;Banana&quot;</span>));</span><br><span class="line">TreeMap&lt;String, String&gt; afterFilter = list.stream()</span><br><span class="line">         .filter(s -&gt; Character.isUpperCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">         .collect(Collectors.toMap(</span><br><span class="line">               s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">               s -&gt; s,</span><br><span class="line">               (oldVal, newVal) -&gt; newVal,</span><br><span class="line">               TreeMap::<span class="keyword">new</span></span><br><span class="line">         ));</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后新集合为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后新集合为：&#123;A=Ackee, B=Banana, O=Orange&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面这串代码中先用<code>.filter()</code>筛选出首字母大写的单词</p>
<p>接下来的<code>toMap()</code>中，第一个参数提取出首字母，第二个参数为这个单词本身，第三个参数为遇到同键的时候选择后出现的单词，第四个参数规定返回类型为<code>TreeMap</code></p>
<hr>
<p>接下来是<strong>collect(Collectors.joining())</strong></p>
<p>这个方法的作用是拼接字符串，返回类型为<code>String</code></p>
<p>这个方法有三个方法重载，参数分别为空参，带一个参数，带三个参数</p>
<p>如果为空参，那么会直接将流里面的字符串全部拼在一起</p>
<p>如果为一个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joining(CharSequence delimiter)</span><br></pre></td></tr></table></figure>
<p>这个参数将规定每个字符串在拼接的时候用什么拼接</p>
<p>如果为三个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">joining(CharSequence delimiter,</span><br><span class="line">CharSequence prefix,</span><br><span class="line">CharSequence suffix)</span><br></pre></td></tr></table></figure>
<p>第一个参数与上文相同，而第二个和第三个参数分别规定了前缀和后缀</p>
<p>接下来通过一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Ackee&quot;</span>, <span class="string">&quot;acerola&quot;</span>, <span class="string">&quot;Banana&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">afterFilter</span> <span class="operator">=</span> list.stream()</span><br><span class="line">         .filter(s -&gt; Character.isUpperCase(s.charAt(<span class="number">0</span>)))</span><br><span class="line">         .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>));</span><br><span class="line">System.out.printf(<span class="string">&quot;筛选后新集合为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 筛选后新集合为：[Apple, Orange, Ackee, Banana]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里被规范为一般集合输出的方式</p>
<hr>
<p>接下来是<strong>collect(Collectors.groupingBy)</strong></p>
<p>这个方法的作用是通过一个高效的分组器来对输入的元素进行分组</p>
<p>这个方法有三个不同参数的重载，接下来分别介绍每个重载</p>
<p>首先是第一个重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier)</span><br></pre></td></tr></table></figure>
<p>这个重载有一个参数，这个参数决定了其分组的标准</p>
<p>接下来是第二个重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier,</span><br><span class="line">Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<p>第二个重载新增一个了参数用于决定收集到的元素要如何处理</p>
<p>通过源代码可以发现，假设我们这里不填（等价于只有一个参数的形式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier) &#123;</span><br><span class="line">   <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这里默认的处理方式是转换成一个新的集合<code>toList()</code></p>
<p>接下来是有三个参数的重载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier,</span><br><span class="line">Supplier&lt;M&gt; mapFactory,</span><br><span class="line">Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>
<p>这里相较于前文的两个参数多了一个用于规范最后输出类型的参数</p>
<p>需要特别注意的一点是此处原本的第二个参数是放到最后的</p>
<p>接下来通过一个简单的例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   arrayList.add(random.nextInt(<span class="number">1</span>,<span class="number">600</span>));</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; afterFilter = arrayList.stream()</span><br><span class="line">         .sorted()</span><br><span class="line">         .collect(Collectors.groupingBy(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (s &lt; <span class="number">200</span>) <span class="keyword">return</span> <span class="string">&quot;&lt;200&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; <span class="number">400</span>) <span class="keyword">return</span> <span class="string">&quot;&lt;400&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&gt;400&quot;</span>;</span><br><span class="line">         &#125;,TreeMap::<span class="keyword">new</span>,Collectors.toList()));</span><br><span class="line">System.out.printf(<span class="string">&quot;分组后为：%s&quot;</span>, afterFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 分组后为：&#123;&lt;200=[51, 88], &lt;400=[367], &gt;400=[536, 549]&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里的运行逻辑是这样的，首先先将元素排序，之后通过<code>groupingBy()</code>分别分组</p>
<p>这里分组的标准是这样的，假设小于200则进入一组，如果大于200并且小于400则进入第二组，如果都不满足（也就是大于400）则进入最后一组</p>
<p>接下来是要求返回一个TreeMap（去重和排序），由于我们并不需要继续对里面的元素进行第二次处理，所以这里默认即可：<code>Collectors.toList()</code></p>
<p><strong>gather()</strong><br>这个方法为终端操作</p>
<p>gather的作用是对流里面的元素进行转换</p>
<p>接下来简单说明一下具体的用途：</p>
<p>由于源代码里面写的内容是<code>gather(Gatherer&lt;? super T, ?, R&gt; gatherer)</code></p>
<p>这提醒我们应该使用Gatherer接口的一些方法</p>
<p>接下来来简单介绍一下里面一些常用的方法</p>
<p>首先是第一个<code>Gatherers.windowFixed()</code></p>
<p>这个方法的作用是将流里面的元素按照规定的数量进行分割</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;Grape&quot;</span>,<span class="string">&quot;Peach&quot;</span>, <span class="string">&quot;plum&quot;</span>));</span><br><span class="line">List&lt;List&lt;String&gt;&gt; newList = list.stream().gather(Gatherers.windowFixed(<span class="number">3</span>))</span><br><span class="line">         .toList();</span><br><span class="line">System.out.println(newList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [[Apple, banana, Grape], [Peach, plum]]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里规定的数字是3，所以按照每3个为一组的顺序分割，如果最后不满三个也是成一组</p>
<p>具体用途可以用于翻页</p>
<p>假设我们现在想要做出一个简单的翻页效果，那么我们可以直接将这里面的每个东西按数量分别分组，之后直接查询即可</p>
<p>这里简单写一个例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxElements</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Apricot&quot;</span>, <span class="string">&quot;Avocado&quot;</span>,</span><br><span class="line">         <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>, <span class="string">&quot;Blackberry&quot;</span>,</span><br><span class="line">         <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Coconut&quot;</span>, <span class="string">&quot;Cranberry&quot;</span>,</span><br><span class="line">         <span class="string">&quot;Date&quot;</span>, <span class="string">&quot;Dragonfruit&quot;</span>));</span><br><span class="line">List&lt;List&lt;String&gt;&gt; newList = list.stream().gather(Gatherers.windowFixed(maxElements))</span><br><span class="line">         .toList();</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;输入查询的页数（最大不超过%d）：&quot;</span>, newList.size());</span><br><span class="line"><span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> input.nextInt() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (page &gt; newList.size() - <span class="number">1</span> || page &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   System.out.printf(<span class="string">&quot;输入页码超出范围！（最大为%d）&quot;</span>, newList.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取子集合可获取到的最大元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sonListElement</span> <span class="operator">=</span> newList.get(page).size();</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;输入查询的第几个元素（最大不超过%d）：&quot;</span>, sonListElement);</span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> input.nextInt() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (element &gt; sonListElement - <span class="number">1</span> || element &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   System.out.printf(<span class="string">&quot;输入数字超出范围！（最大为%d）&quot;</span>, maxElements);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.printf(<span class="string">&quot;查找的内容为：%s&quot;</span>, newList.get(page).get(element));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入：</span></span><br><span class="line"><span class="comment">// 输入查询的页数（最大不超过4）：3</span></span><br><span class="line"><span class="comment">// 输入查询的第几个元素（最大不超过3）：1</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 查找的内容为：Cherry</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用了<code>Gatherers.windowFixed(maxElements)</code>来实现了将指定数量的元素放到一页的效果</p>
<p>之前在介绍<code>limit()</code>和<code>skip()</code>的时候，也实现了翻页的效果，但是那个翻页原理是通过跳过一定的元素来实现的翻页</p>
<p>而这里是通过创建子集合来实现的翻页效果</p>
<p>接下来介绍<code>Gatherers.windowSliding()</code></p>
<p>这个方法的作用是，收集n个元素为一组，之后每次减去最前面一个元素，新增后一个元素，并返回一个新的集合</p>
<p>说白了就是以n为单位一点一点往集合最后挪过去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Apricot&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>,</span><br><span class="line">         <span class="string">&quot;Cherry&quot;</span>));</span><br><span class="line">List&lt;List&lt;String&gt;&gt; newList = list.stream().gather(Gatherers.windowSliding(<span class="number">2</span>))</span><br><span class="line">         .toList();</span><br><span class="line">System.out.println(newList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [[Apple, Apricot], [Apricot, Blueberry], [Blueberry, Cherry]]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里首先收集两个元素作为一组，之后减去第一个元素<code>Apple</code>，新增后一个元素<code>Blueberry</code></p>
<p>以此类推直到集合结束</p>
<p>接下来介绍<code>Gatherers.mapConcurrent()</code></p>
<p>这个方法有两个参数，不过在讲这两个参数的作用之前我们需要先介绍一下这个方法是干什么用的</p>
<p><code>Gatherers.mapConcurrent()</code>的作用是，并发处理多个元素</p>
<p>简单来说就是一次性处理多个元素</p>
<p>接下来介绍参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapConcurrent(</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> maxConcurrency,</span><br><span class="line"><span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>第一个参数为<code>maxConcurrency</code>意思是可以同时执行的操作的数量</p>
<p>第二个为<code>mapper</code>，意思是每个元素要执行的操作</p>
<p>接下来通过一个简单的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ids = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">List&lt;String&gt; users = ids.stream()</span><br><span class="line">         .gather(Gatherers.mapConcurrent(<span class="number">2</span>, s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&quot;</span> + s;</span><br><span class="line">         &#125;))</span><br><span class="line">         .toList();</span><br><span class="line">System.out.println(users);</span><br><span class="line">System.out.println(<span class="string">&quot;耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [UserA, UserB, UserC, UserD, UserE]</span></span><br><span class="line"><span class="comment">// 耗时: 1521 ms</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里在每次处理时要求<code>sleep</code>500ms后才执行处理</p>
<p>而这里最大并发数为2，意味着可以同时运行2个任务，而一共5个元素只需要处理3次即可，所以总时长便是~1500ms</p>
<p>假设不使用并发处理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ids = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">List&lt;String&gt; users = ids.stream()</span><br><span class="line">         .map(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&quot;</span> + s;</span><br><span class="line">         &#125;)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.println(users);</span><br><span class="line">System.out.println(<span class="string">&quot;耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [UserA, UserB, UserC, UserD, UserE]</span></span><br><span class="line"><span class="comment">// 耗时: 2505 ms</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里是一个操作结束后才会执行下一个操作，总花费时间便为5 x 500ms</p>
<p>那么这时候就有人要问了，诶，那么这个这么好用，是不是<code>maxConcurrency</code>越大越好呢？</p>
<p>当然不是！越大意味着要同时消耗的资源就越多，所以一般10~100就够用了</p>
<p>并且这个操作只适合I&#x2F;O 密集型的任务，如果只是为了计算的话，建议使用并行流</p>
<p><strong>parallelStream()</strong><br>这个方法为中间操作</p>
<p>这个方法为<strong>并发流</strong>，具体的使用方法与上文的<code>stream()</code>完全一致，所以之类不再花时间介绍</p>
<p>不过需要注意的一点是，由于这是并发流的原因，有些依照顺序处理的方法可能会出现一些小小的<strong>偏差</strong></p>
<p>这里简单举一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">list.parallelStream()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （示例）输出：</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出<strong>完全不按照顺序</strong>，为什么加上一个示例呢？因为这个输出的内容是完全随机的，没办法预测到的</p>
<p>特别需要注意的一点是，使用这个方法必须做到<strong>无副作用和线程安全</strong></p>
<p>如果有副作用会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">list.parallelStream()</span><br><span class="line">         .forEach(s -&gt; arrayList.add(s * s));</span><br><span class="line">System.out.printf(<span class="string">&quot;在并发流里面使用带有副作用的lambda：%s&quot;</span>, arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 在并发流里面使用带有副作用的lambda：[16, 36, 25, 4, 9, 1]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里无法预测输出是什么结果</p>
<p>但如果真的要这样处理得怎么办呢？</p>
<p>可以使用map和toList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">List&lt;Integer&gt; newList = list.parallelStream()</span><br><span class="line">         .map(s -&gt; s * s)</span><br><span class="line">         .toList();</span><br><span class="line">System.out.printf(<span class="string">&quot;正常的处理：%s&quot;</span>, newList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 正常的处理：[1, 4, 9, 16, 25, 36]</span></span><br></pre></td></tr></table></figure>

<p>这里的副作用来自于<code>.add()</code>，由于<code>ArrayList</code>并不是线程安全的，试图并发add可能导致出现一些奇奇怪怪的问题</p>
<p><strong>spliterator()</strong><br>该方法是一个终端操作</p>
<p>该方法常见便是返回一个spliterator对象，而这个对象提供遍历和分割的能力</p>
<p>这个方法有很多方法可以使用，接下来简单介绍一下：</p>
<p>首先第一个是<strong>trySplit()</strong></p>
<p>这个方法的作用是将当前流从中间分割，并且分为两个新的Spliterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; oldStream = list.stream().spliterator();</span><br><span class="line">Spliterator&lt;Integer&gt; newSplit = oldStream</span><br><span class="line">         .trySplit();</span><br><span class="line"><span class="keyword">if</span> (newSplit != <span class="literal">null</span>) &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;拆分成功！&quot;</span>);</span><br><span class="line">   System.out.printf(<span class="string">&quot;分割后oldStream预计大小为：%s%n&quot;</span>, oldStream.estimateSize());</span><br><span class="line">   System.out.printf(<span class="string">&quot;当前分割预计大小为：%s%n&quot;</span>, newSplit.estimateSize());</span><br><span class="line"></span><br><span class="line">   System.out.printf(<span class="string">&quot;%n当前oldStream包含了：&quot;</span>);</span><br><span class="line">   oldStream.forEachRemaining(s -&gt; System.out.printf(<span class="string">&quot;%s &quot;</span>, s));</span><br><span class="line"></span><br><span class="line">   System.out.printf(<span class="string">&quot;%n当前newSplit包含了：&quot;</span>);</span><br><span class="line">   newSplit.forEachRemaining(s -&gt; System.out.printf(<span class="string">&quot;%s &quot;</span>, s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 拆分成功！</span></span><br><span class="line"><span class="comment">// 分割后oldStream预计大小为：4</span></span><br><span class="line"><span class="comment">// 当前分割预计大小为：4</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当前oldStream包含了：5 6 7 8 </span></span><br><span class="line"><span class="comment">// 当前newSplit包含了：1 2 3 4 </span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里trySplit将原本的流分割成了两个新的部分</p>
<p>如果这里只有奇数个元素，那么分割出去的newSplit就只有（（向下取整）（总数 &#x2F; 2））个元素，例如总共有7个，那么oldStream会分到4个，而newSplit会分到3个元素</p>
<p>接下来看具体的实现，由于trySplit来自接口Spliterator，所以具体实现得看对应的使用</p>
<p>这里以ArrayList为例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayListSpliterator <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> (lo &gt;= mid) ? <span class="literal">null</span> : <span class="comment">// divide range in half unless too small</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">ArrayListSpliterator</span>(lo, index = mid, expectedModCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中hi为集合的边界，lo为一开始的位置，此处使用了&gt;&gt;&gt;1来代替除以2，避免了溢出的情况</p>
<p>接下来是三元表达式判断条件，如果不满足则直接返回null，满足则返回一个新的<code>ArrayListSpliterator</code>（其实也就是Spliterator）</p>
<p>接下来是<code>estimateSize()</code></p>
<p>这个方法的作用是返回该Spliterator估计还能返回的长度</p>
<p>上文在trySplit的例子中也有使用到这个方法，这里简单举一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; oldStream = list.stream().spliterator();</span><br><span class="line"><span class="type">long</span> <span class="variable">estimateSize</span> <span class="operator">=</span> oldStream</span><br><span class="line">         .estimateSize();</span><br><span class="line">System.out.printf(<span class="string">&quot;该Spliterator估计还能返回的长度为：%d&quot;</span>, estimateSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该Spliterator估计还能返回的长度为：7</span></span><br></pre></td></tr></table></figure>

<p>从<code>ArrayList.java</code>也可以很轻松找到对应的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getFence() - index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是实际的返回是最右端（getFence()）和最开始的差（index）</p>
<h5 id="补充点：精确求值"><a href="#补充点：精确求值" class="headerlink" title="补充点：精确求值"></a>补充点：精确求值</h5><p>在ArrayList这里<code>estimateSize</code>是返回精确值的，我们可以称之为<strong>SIZED</strong></p>
<p>可以通过如下操作来获取是否为精确的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isSized</span> <span class="operator">=</span> spliterator</span><br><span class="line">         .hasCharacteristics(Spliterator.SIZED);</span><br><span class="line">System.out.printf(<span class="string">&quot;该Spliterator是否为精确的（SIZED）：%s&quot;</span>, isSized);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 该Spliterator是否为精确的（SIZED）：true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>具体内容请参照hasCharacteristics的内容</p>
</blockquote>
<p>如果这里为精确的，那么便可以使用<code>estimateSize</code>得到精确值</p>
<p>如果不为精确的，那么可能会出现一些偏差</p>
<p>例如这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">5</span>);</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = stream.spliterator();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isSized</span> <span class="operator">=</span> spliterator</span><br><span class="line">         .hasCharacteristics(Spliterator.SIZED);</span><br><span class="line">System.out.printf(<span class="string">&quot;该Spliterator是否为精确的（SIZED）：%s&quot;</span>, isSized);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该Spliterator是否为精确的（SIZED）：false</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里结果为false，也就是说不是精确的，假设我们现在试图用estimateSize获取长度，那么会怎么样？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">5</span>);</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = stream.spliterator();</span><br><span class="line"><span class="type">long</span> <span class="variable">streamSize</span> <span class="operator">=</span> spliterator</span><br><span class="line">         .estimateSize();</span><br><span class="line">System.out.printf(<span class="string">&quot;该Spliterator估计长度为：%d&quot;</span>, streamSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该Spliterator估计长度为：9223372036854775807</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里返回的结果是 (2^63) - 1，也就是64位整数的极限，这也说明了不是是准确的</p>
<p>接下来是<strong>forEachRemaining</strong></p>
<p>这个方法的作用是遍历<code>Spliterator</code>里面的元素</p>
<p>需要注意的一点是，使用<code>forEachRemaining</code>之后，这个<code>Spliterator</code>便会被消费，之后若试图再次使用<code>forEachRemaining</code>便不会输出任何内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line">spliterator.forEachRemaining(x -&gt; System.out.println(x * x));</span><br><span class="line">spliterator.forEachRemaining(x -&gt; System.out.println(x * x * x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line"><span class="comment">// 25</span></span><br><span class="line"><span class="comment">// 36</span></span><br></pre></td></tr></table></figure>
<p>此处可以看到，在第一次输出数的平方后，再次使用试图输出数的立方时是没有任何效果的</p>
<p>这也说明了在使用<code>forEachRemaining</code>后，这个<code>spliterator</code>便直接结束了</p>
<p>接下来是<code>characteristics()</code></p>
<p>这个方法的作用是获取到该spliterator的位掩码</p>
<h5 id="补充点：位掩码（Bitmask）"><a href="#补充点：位掩码（Bitmask）" class="headerlink" title="补充点：位掩码（Bitmask）"></a>补充点：位掩码（Bitmask）</h5><p>那么是什么是位掩码（Bitmask）呢？</p>
<p>简单来讲就是通过一个数字的二进制的0和1来存储指定的布尔信息</p>
<p>Java中characteristics为int类型，该类型为32位</p>
<p>用二进制表示便是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>
<p>这里每一位便是一个“开关”，总共可以表示<strong>32种布尔状态</strong></p>
<p>我们以spliterator中的SIZED为例，在spliterator.java中可以找到其位掩码所代表的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZED</span> <span class="operator">=</span> <span class="number">0x00000040</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是一个十六进制数，简单换算一下可以得到为十进制的<code>64</code>和二进制的<code>1000000</code></p>
<p>这里1在第7位，意味着在32位中第七位代表<code>SIZED</code>的状态</p>
<p>也就是当出现以下情况的时候（其他位不计，只看第七位），就代表这个spliterator有<code>SIZED</code>属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01000000</span></span><br></pre></td></tr></table></figure>
<hr>
<p>在补充完位掩码的相关内容后，便开始介绍这个方法的具体用途</p>
<p>上面的也提及到说这个方法的作用是返回该spliterator的位掩码</p>
<p>我们简单通过一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="type">int</span> <span class="variable">characteristics</span> <span class="operator">=</span> spliterator.characteristics();</span><br><span class="line">System.out.printf(<span class="string">&quot;位掩码：%d (0x%X)%n&quot;</span>, characteristics, characteristics);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 位掩码：16464 (0x4050)</span></span><br></pre></td></tr></table></figure>
<p>很好，我们成功获取到了一个位掩码，那么接下来要怎么计算到这个spliterator有什么属性呢？</p>
<p>从上文我们可以知道，要想判断是否有该属性，只需要在二进制的这个位为1，即可</p>
<p>那么我们便需要找到一个可以满足以下条件的运算符</p>
<p>当a与b同为1时，返回1，当a与b任意一个出现0的时候，返回0</p>
<p>稍微思考一下便可以想起位运算符：按位与（&amp;）</p>
<p>如此，我们便可以这样计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="type">int</span> <span class="variable">characteristics</span> <span class="operator">=</span> spliterator.characteristics();</span><br><span class="line">System.out.printf(<span class="string">&quot;位掩码：%d (0x%X)%n&quot;</span>, characteristics, characteristics);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;ORDERED: &quot;</span> + ((characteristics &amp; Spliterator.ORDERED) != <span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;SORTED: &quot;</span> + ((characteristics &amp; Spliterator.SORTED) != <span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;SIZED: &quot;</span> + ((characteristics &amp; Spliterator.SIZED) != <span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;SUBSIZED: &quot;</span> + ((characteristics &amp; Spliterator.SUBSIZED) != <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 此处仅列出几个，剩下的会在之后介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 位掩码：16464 (0x4050)</span></span><br><span class="line"><span class="comment">// ORDERED: true</span></span><br><span class="line"><span class="comment">// SORTED: false</span></span><br><span class="line"><span class="comment">// SIZED: true</span></span><br><span class="line"><span class="comment">// SUBSIZED: true</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里spliterator有以下属性：<code>ORDERED</code>、<code>SIZED</code>、<code>SUBSIZED</code></p>
<h5 id="补充点：关于属性"><a href="#补充点：关于属性" class="headerlink" title="补充点：关于属性"></a>补充点：关于属性</h5><p>虽然我们获取到这个spliterator的属性，但是我们还是不知道这些属性有什么具体的用途</p>
<p>那么接下来便来具体的介绍这些属性的作用，分别代表了该spliterator有什么特点</p>
<p>在介绍的时候会顺带附上其十六进制码，以及对应的二进制位数，来源均来自<code>spliterator.java</code></p>
<p><strong>ORDERED</strong><br>ORDERED的十六进制码为：<code>0x00000010</code>，二进制为：<code>10000</code></p>
<p>这个属性用于表明该spliterator顺序是否会保持插入顺序</p>
<p>假设这个属性为true，那么元素在处理的时候会与插入的顺序保持一致，即使并行处理也会保持顺序</p>
<p>在多次执行的时候顺序均一致</p>
<p><strong>SIZED</strong><br>SIZED的十六进制码为：<code>0x00000040</code>，二进制为：<code>1000000</code></p>
<p>这个属性用于表示是否可以查询到精确大小</p>
<p>如果为true，则会返回精确的大小，如果为false，一般在使用<code>estimateSize()</code>返回大小的时候会返回long.MAX_VALUE，当然也有可能返回一个随机的值</p>
<p>具体参照这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Returns an estimate of the number of elements that would be</span><br><span class="line">encountered by a forEachRemaining traversal, or returns</span><br><span class="line">Long#MAX_VALUE <span class="keyword">if</span> infinite, unknown, or too expensive to compute.</span><br></pre></td></tr></table></figure>

<p><strong>SUBSIZED</strong><br>SIZED的十六进制码为：<code>0x00004000</code>，二进制为：<code>100000000000000（1在第15位）</code></p>
<p>这个属性表示子分割是否知道具体大小</p>
<p>利用这个属性可以预测在并行任务中的处理时间</p>
<p><strong>DISTINCT</strong><br>DISTINCT的十六进制码为：<code>0x00000001</code>，二进制为：<code>1</code></p>
<p>这个属性表示spliterator中是否元素唯一</p>
<p><strong>SORTED</strong><br>SORTED的十六进制码为：<code>0x00000004</code>，二进制为：<code>100</code></p>
<p>这个属性表示该spliterator是否元素是否已排序</p>
<p><strong>IMMUTABLE</strong><br>IMMUTABLE的十六进制码为：<code>0x00000400</code>，二进制为：<code>10000000000（1在第11位）</code></p>
<p>这个属性表示该spliterator是否不可变（也就是能不能使用add、remove这些方法来修改）</p>
<p><strong>CONCURRENT</strong><br>CONCURRENT的十六进制码为：<code>0x00001000</code>，二进制为：<code>1000000000000（1在第13位）</code></p>
<p>这个属性表示该spliterator是否并发安全</p>
<p>接下来是<strong>hasCharacteristics()</strong></p>
<p>这个方法的作用是帮我们计算是否有该属性</p>
<p>相当于帮我们做了一次按位与的计算</p>
<p>通过源代码中，也可以看到实际上便是如此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">hasCharacteristics</span><span class="params">(<span class="type">int</span> characteristics)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (characteristics() &amp; characteristics) == characteristics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来通过一个具体的例子来说明一下如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSized</span> <span class="operator">=</span> spliterator.hasCharacteristics(Spliterator.SIZED);</span><br><span class="line">System.out.printf(<span class="string">&quot;该spliterator是否有属性SIZED：%s&quot;</span>, isSized);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该spliterator是否有属性SIZED：true</span></span><br></pre></td></tr></table></figure>
<p>通过这样便可以更加简便地判断出这个spliterator到底有什么属性</p>
<p>接下来是<strong>tryAdvance()</strong></p>
<p>这个方法的作用是尝试执行一个操作并返回是否执行成功的布尔值</p>
<p>需要注意的是，每次执行这个操作都会使得这个元素被消费掉，无法再次使用</p>
<p>我们可以借此来简单实现一个遍历的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="keyword">while</span> (spliterator.tryAdvance(System.out::println));</span><br></pre></td></tr></table></figure>
<p>如果tryAdvance成功执行括号内的操作，那么会返回True，这就导致了可以将这个语句放进判断中，直到该spliterator内元素全部被消耗完</p>
<p>接下来是<strong>getExactSizeIfKnown()</strong></p>
<p>这个方法的作用是：如果该spliterator具有SIZED属性，那么返回其精确的数量，如果没有，则返回-1</p>
<p>举一个简单的例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">Spliterator&lt;Integer&gt; spliterator = list.stream().spliterator();</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> spliterator.getExactSizeIfKnown();</span><br><span class="line">System.out.printf(<span class="string">&quot;其精确数量为：%d&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 其精确数量为：6</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里输出为精确的数量</p>
<p>但如果没有SIZED这个属性，那么会是这个结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spliterator&lt;Integer&gt; spliterator = Stream.iterate(<span class="number">1</span>,n -&gt; n + <span class="number">1</span>).limit(<span class="number">100</span>).spliterator();</span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> spliterator.getExactSizeIfKnown();</span><br><span class="line">System.out.printf(<span class="string">&quot;其精确数量为：%d&quot;</span>, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 其精确数量为：-1</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>接下来讲讲LinkedList</p>
<p>LinkedList是一个双向链表，那么什么是双向链表呢</p>
<p><strong>双向链表</strong><br>简单来讲，双向链表是一种线性数据结构，特点是链表中的每个元素都包含<strong>两个指针</strong></p>
<p>这两个指针分别指着什么呢？一个指针指向前一个节点，而第二个指针指向后一个节点</p>
<p>这样做的好处是各个元素之间紧密相连</p>
<p>而这意味着什么？以往的单向链表只有一个后驱指针，意味着如果想要查询上一个元素，<strong>必须要把整个链表遍历一遍</strong>，这大大影响了运行效率</p>
<p>双向链表由于带两个指针，所以在查询上一个元素时会快很多</p>
<h4 id="特性-优点"><a href="#特性-优点" class="headerlink" title="特性 &#x2F; 优点"></a>特性 &#x2F; 优点</h4><p>接下来讲讲有关LinkedList的一些特性</p>
<p>在上文也提及到了其作为双向列表，所以其可以快速查询上一个元素的特性有什么作用呢？</p>
<p>由于这个特点，LinkedList在插入元素的效率是<strong>很快</strong>的</p>
<p>我们可以举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Instant</span> <span class="variable">arrayStartTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000000</span>; ++i)&#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">arrayEndTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;ArrayList插入元素时间为：%s\n&quot;</span>,Duration.between(arrayStartTime,arrayEndTime).toMillis());</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们使用了计时器计时插入1000000个元素的时间</p>
<p>ArrayList花费的时间大概为11毫秒左右</p>
<p>那么LinkedList呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Instant</span> <span class="variable">linkedStartTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">   linkedList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">linkedEndTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;LinkedList插入元素时间为：%s\n&quot;</span>,Duration.between(linkedStartTime,linkedEndTime).toMillis());</span><br></pre></td></tr></table></figure>
<p>这里同样计时了1000000个元素插入所需要的时间</p>
<p>不同的是，这里使用的是LinkedList，花费的时间大概为<strong>4毫秒</strong></p>
<p>在插入元素方面，LinkedList的效率要<strong>远快于</strong>ArrayList！</p>
<h4 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h4><p>在讲完LinkedList的一些特点之后，便可以开始介绍其具体的用法了</p>
<p>由于LinkedList本质还是属于<code>Link接口</code>，所以很多方法还是通用的（比如说<code>add()</code>、<code>get()</code>）</p>
<p>接下来主要介绍那些特有的方法</p>
<p><strong>offer()</strong><br>offer()是一个用于插入元素的方法，具体实现效果跟add()差不多</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;String&gt; linkedList1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">linkedList.add(<span class="string">&quot;Hello,this is add()&quot;</span>);</span><br><span class="line">linkedList1.offer(<span class="string">&quot;Hello,this is offer()&quot;</span>);</span><br><span class="line">System.out.println(linkedList.getFirst());</span><br><span class="line">System.out.println(linkedList1.getFirst());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello,this is add()</span></span><br><span class="line"><span class="comment">// Hello,this is offer()</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这两个方法都可以实现插入的效果</p>
<p>offer()拥有与add()一样的两个方法，首位插入和末尾插入：<code>offerFirst()</code>、<code>offerLast()</code></p>
<h5 id="add-与offer"><a href="#add-与offer" class="headerlink" title="add()与offer()"></a>add()与offer()</h5><p>诶，这里可能就有人要说了，那这样算不算一种设计冗余呢？</p>
<p>其实不然</p>
<p>在LinkedList中，offer()方法实现的是Deque接口 &#x2F; Queue接口</p>
<p>而add()方法实现了List接口，两者虽然效果上是相等的，但是并不属于同一个接口</p>
<p>那么还有什么区别呢？</p>
<p>首先，add方法一般是作为列表的插入操作，而offer一般用于队列</p>
<p>假设我们现在想要插入一个满空间的列表，使用add方法会导致抛出报错<code>IllegalStateException</code></p>
<p>但是，offer方法不会抛出报错，只会返回<code>false</code></p>
<blockquote>
<p>不过由于LinkedList是无界的，所以不存在空间不够的情况<del>（当然内存不够依旧会报错）</del></p>
</blockquote>
<p>说的直白一点就是：<strong>add()是不成功就报错，而offer()是不成功就返回false</strong></p>
<hr>
<p><strong>poll()</strong><br>接下来讲的方法是poll()，与前文的offer()一样，这个方法归属于Deque接口 &#x2F; Queue接口</p>
<p>所以，在List接口中等价的方法为：<code>remove()</code></p>
<p>以下是其基本的使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100</span>; ++i)&#123;</span><br><span class="line">   linkedList.add(<span class="string">&quot;Hello,this is poll() _&quot;</span>+(i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span> ;++i)&#123;</span><br><span class="line">   System.out.println(linkedList.poll());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello,this is poll() _1</span></span><br><span class="line"><span class="comment">// Hello,this is poll() _2</span></span><br><span class="line"><span class="comment">// Hello,this is poll() _3</span></span><br></pre></td></tr></table></figure>
<p>poll()的返回值为其删除的元素，这一点与remove()是一致的</p>
<p>同remove()一致，poll()也有用于移除首尾项的方法：<code>pollFirst()</code>、以及<code>pollLast()</code></p>
<h5 id="poll-与remove"><a href="#poll-与remove" class="headerlink" title="poll()与remove()"></a>poll()与remove()</h5><p>接下来讲讲这两者的区别</p>
<p>由于这两个功能上基本一致，所以差异的地方只有一些细节的点</p>
<p>假设现在LinkedList是一个空的链表，那么此时使用remove会抛出一个叫做<code>NoSuchElementException</code>的报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">System.out.println(<span class="string">&quot;文件正常编译&quot;</span>);</span><br><span class="line">System.out.println(linkedList.remove());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 文件正常编译</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.util.NoSuchElementException</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在IntelliJ IDEA中，如果使用该操作，则会有一个警告：对空集合 ‘linkedList’ 进行的更新操作无效</p>
</blockquote>
<p>但如果选择poll()来删除元素，那么就大不相同了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">System.out.println(<span class="string">&quot;文件正常编译&quot;</span>);</span><br><span class="line">System.out.println(linkedList.poll());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 文件正常编译</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里并没有报错，而是选择了返回一个<code>null</code></p>
<p>从<code>LinkedList.java</code>观察两者的源代码可以发现这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是poll()的实现代码</span></span><br><span class="line"><span class="comment">// 可以发现如果为空则返回null</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">   <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是<code>remove()</code></p>
<p>由于remove()的实现方法稍微有点抽象，这里把两个方法都展示出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">   <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">   <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比两者可以发现，两者的逻辑是一致的（一个用三元表达式一个用if语句），只是一个选择返回null，而另一个选择抛出异常<code>NoSuchElementException</code></p>
<hr>
<p><strong>peek()</strong><br>接下来介绍的方法是peek()</p>
<p>这个方法的作用是返回头部元素的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">list.offer(<span class="string">&quot;Hello! Nice to meet you&quot;</span>);</span><br><span class="line">list.offer(<span class="string">&quot;Hello! How are you?&quot;</span>);</span><br><span class="line">System.out.println(list.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello! Nice to meet you</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法成功返回了我们的第一项元素</p>
<p>这里可能有人就会想到一个方法了：<code>get()</code></p>
<p>但与之前的两个方法不同的是，这个方法并不与<code>get()</code>方法类似</p>
<p><code>get()</code>可以返回指定的索引，而<code>peek()</code>却只能固定返回一个位置的索引</p>
<hr>
<p>接下来是<code>peek()</code>的两个额外的方法，分别是返回头部元素的<code>peekFirst()</code>、和返回尾部元素的<code>peekLast()</code></p>
<p>通过一个简单的例子来说明这两个方法的实际用途：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">100</span> ; ++i)&#123;</span><br><span class="line">   list.offer(<span class="string">&quot;Hello!This is Number &quot;</span>+ (i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;第一个元素为：%s\n&quot;</span>,list.peekFirst());</span><br><span class="line">System.out.printf(<span class="string">&quot;最后一个元素为：%s&quot;</span>,list.peekLast());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 第一个元素为：Hello!This is Number 1</span></span><br><span class="line"><span class="comment">// 最后一个元素为：Hello!This is Number 100</span></span><br></pre></td></tr></table></figure>

<h5 id="一些补充的话"><a href="#一些补充的话" class="headerlink" title="一些补充的话"></a>一些补充的话</h5><p>由于<code>LinkedList</code>实现了Deque接口以及Queue接口这些ArrayList没有的接口，所以此处会补充这部分的内容</p>
<h4 id="补充用法"><a href="#补充用法" class="headerlink" title="补充用法"></a>补充用法</h4><p>接下来将补充一些Queue和Deque接口有的方法：</p>
<p>一些基本的（如getFirst()，getLast()）就不再说明</p>
<p><strong>push()</strong><br><code>push()</code>方法来源于Deque接口</p>
<p>这个方法等价于<code>addFirst()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">list.push(<span class="string">&quot;使用push方法添加元素\n&quot;</span>);</span><br><span class="line">list.addFirst(<span class="string">&quot;使用addFirst方法添加元素\n&quot;</span>);</span><br><span class="line">System.out.printf(list.getFirst());</span><br><span class="line">System.out.printf(list.getLast());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用addFirst方法添加元素</span></span><br><span class="line"><span class="comment">// 使用push方法添加元素</span></span><br></pre></td></tr></table></figure>
<p>从输出结果来看，这两个方法的结果是完全一致的，那么，这两个方法有没有什么不同呢？</p>
<p>其实是几乎没有的，我们不妨看看这两个方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，push方法的实现其实也就是调用了addFirst方法</p>
<p>但一般而言，如果将LinkedList当做栈使用，则会使用push（代表压入栈顶）</p>
<p>这样可以使得代码更加明确</p>
<p><strong>removeFirstOccurrence</strong><br>这个方法有另外一个版本：<code>removeLastOccurrence</code></p>
<p>不过核心功能大同小异，主要是索引方向不同</p>
<p>这个方法的作用为从首项开始搜寻是否有存在目标项，如果存在，则移除并返回<code>true</code></p>
<p>接下来是具体的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt;<span class="number">100</span> ; ++ i)&#123;</span><br><span class="line">   list.offer(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(String.valueOf(list.removeFirstOccurrence(<span class="string">&quot;Hello2&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我们不妨看看他的源代码是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">         <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">            unlink(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">         <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">            unlink(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>removeFirstOccurrence()</code>其实也就是调用了<code>remove()</code>这个方法</p>
<p><strong>descendingIterator</strong><br>接下来将说明一下这个方法</p>
<p>这个方法的作用是将当前数组反向</p>
<p>在反向的时候需要新创建一个迭代器对象才可以起到效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt;<span class="number">100</span> ; ++ i)&#123;</span><br><span class="line">   list.offer(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;未使用降序迭代器的首项：%s\n&quot;</span>,list.peek());</span><br><span class="line">Iterator&lt;String&gt;lst =  list.descendingIterator();</span><br><span class="line">System.out.printf(<span class="string">&quot;使用降序迭代器后的首项：%s\n&quot;</span>,lst.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 未使用降序迭代器的首项：Hello0</span></span><br><span class="line"><span class="comment">// 使用降序迭代器后的首项：Hello99</span></span><br></pre></td></tr></table></figure>

<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p>Set接口是另一个常见的接口，主要分为以下几个实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet：基于哈希表的实现类，可以存储不重复元素，查询效率高（时间复杂度O(<span class="number">1</span>)）</span><br><span class="line">TreeSet：基于红黑树的实现类，可以存储不重复元素，可以用于排序</span><br><span class="line">LinkedHashSet：基于哈希表和链表的实现类，存储不重复元素并且保持插入顺序（链表特性）</span><br><span class="line">ConcurrentSkipListSet：基于跳表，支持并发操作（线程安全），同时可以保持元素排序</span><br><span class="line">CopyOnWriteArraySet：基于CopyOnWriteArrayList，由于边写边复制所以线程安全，可以存储不重复元素</span><br></pre></td></tr></table></figure>
<p>那么接下来将依次介绍这些实现类</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>首先第一个是HashSet</p>
<p>HashSet是一个经典的实现类，其底层为HashMap，这个实现类支持哈希表，由于这个原因，HashSet查找元素时平均时间复杂度为<code>O(1)</code></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>接下来讲讲HashSet的一些特性：</p>
<p>首先第一个便是Set接口的通性：<strong>不允许存放相同元素</strong></p>
<p>第二个特性是无序性，简单来说就是传入的顺序与输出的顺序是不同的</p>
<p>举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">   list.add(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String num : list)&#123;</span><br><span class="line">   System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Hello0</span></span><br><span class="line"><span class="comment">// Hello1</span></span><br><span class="line"><span class="comment">// Hello4</span></span><br><span class="line"><span class="comment">// Hello2</span></span><br><span class="line"><span class="comment">// Hello3</span></span><br></pre></td></tr></table></figure>
<p>通过这个例子可以充分体现出其无序性，这一点与链表相分开</p>
<p>此外，HashSet是允许<code>null</code>元素的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">for</span>(String num : list)&#123;</span><br><span class="line">   System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>一个需要注意的点是，HashSet并不是一个线程安全的实现类，如果在多线程的情况下，必须要做到外部同步</p>
<h4 id="具体用法-1"><a href="#具体用法-1" class="headerlink" title="具体用法"></a>具体用法</h4><p>在介绍完这些特性之后，便要来介绍HashSet的具体用法了，与前文的List接口一致，此处介绍的方法如果在下面的实现类中再次出现将不会再次介绍</p>
<p>但由于HashSet的接口Set接口完全继承与Collection接口，而Collection接口的方法我们在前文ArrayList的部分已经讲过了，所以这里便不再复述</p>
<p>也就是说，HashSet并没有<strong>任何独立</strong>的公共方法</p>
<h4 id="HashSet存在的意义"><a href="#HashSet存在的意义" class="headerlink" title="HashSet存在的意义"></a>HashSet存在的意义</h4><p>既然没有独立的方法，那么HashSet存在的意义是什么呢？</p>
<p>在之前我们也提到过了，HashSet存储不重复的元素，这也就导致了如果有相同的元素被相继加入到数组中，那么HashSet只会存储前一个，而后一个并不会存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(String num : list)&#123;</span><br><span class="line">   System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// aaa</span></span><br><span class="line"><span class="comment">// bbb</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上是，如果你在IntelliJ IDEA里面add()两个相同的元素，那么会抛出一个警告：重复的 Set 元素</p>
</blockquote>
<p>接下来是其独特的特性：<strong>极快的查询速度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">99999999</span>; ++i)&#123;</span><br><span class="line">   arrayList.add(<span class="string">&quot;Hello&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">arrayStartTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(arrayList.contains(<span class="string">&quot;Hello&quot;</span>+<span class="number">9999999</span>));</span><br><span class="line"><span class="type">Instant</span> <span class="variable">arrayEndTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;ArrayList查询指定元素时间为：%s\n&quot;</span>, Duration.between(arrayStartTime,arrayEndTime).toNanos());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// ArrayList查询指定元素时间为：65384600</span></span><br></pre></td></tr></table></figure>

<p>那么让我们看看HashSet咋以相同代码下的查询速度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">99999999</span>; i++) &#123;</span><br><span class="line">   hashList.add(<span class="string">&quot;hello&quot;</span>+ i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Instant</span> <span class="variable">hashStartTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(hashList.contains(<span class="string">&quot;hello&quot;</span>+<span class="number">9999999</span>));</span><br><span class="line"><span class="type">Instant</span> <span class="variable">hashEndTime</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;HashSet查询指定元素的时间为：%s\n&quot;</span>,Duration.between(hashStartTime,hashEndTime).toNanos());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// HashSet查询指定元素的时间为：0</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里HashSet查找的速度远远大于ArrayList，这也可以突出其特点</p>
<h4 id="补充点：快速失败（fail-fast）"><a href="#补充点：快速失败（fail-fast）" class="headerlink" title="补充点：快速失败（fail-fast）"></a>补充点：快速失败（fail-fast）</h4><p>快速失败是一个很有意思的机制，部分实现类拥有这个特性</p>
<p>会出现这个特性的原因是因为迭代器的问题</p>
<p>如果你在使用迭代器的时候同时用非迭代器方法修改这个集合（比如说add()），那么此时迭代器会瞬间检测到这一修改并且抛出错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; hashList = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">hashList.add(<span class="string">&quot;hello！&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = hashList.iterator();</span><br><span class="line"><span class="keyword">for</span> (; iterator.hasNext(); iterator.next() ) &#123;</span><br><span class="line">   hashList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里抛出了报错<code>ConcurrentModificationException</code></p>
<p>那么为什么会这样呢？</p>
<p>首先我们需要知道一个有意思的点：<code>modCount</code></p>
<p>这个是什么呢？简单来说就是记录你对这个集合操作的次数</p>
<p>我们直接看源码可以发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line"><span class="comment">// putVal()方法</span></span><br><span class="line">...<span class="comment">//省略</span></span><br><span class="line">++modCount;</span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">   resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果你对这个集合进行了一些操作，那么这个计数器都会记录操作的次数</p>
<p>那这跟快速失败有什么关联呢</p>
<p>在生成一个迭代器的时候，迭代器会讲modCount的值复制一遍，存储到：<code>expectedModCount</code>中</p>
<p>使用迭代器的方法<code>next()</code>或者<code>remove()</code>的时候，便会将这个值与<code>modCount</code>进行对比，如果两者相等则说明没有进行任何修改操作</p>
<p>则正常进行</p>
<p>但如果修改（例如上面提到的例子一样），则会直接抛出报错：ConcurrentModificationException</p>
<p>特别补充的一点是，modCount这个属性是<code>private</code>的，所以不用担心会被修改</p>
<p>另外，如果需要删除元素可以选择迭代器自带的删除方法：<code>remove()</code></p>
<hr>
<h4 id="补充点：底层实现"><a href="#补充点：底层实现" class="headerlink" title="补充点：底层实现"></a>补充点：底层实现</h4><p>接下来聊聊HashSet的底层实现</p>
<p>首先第一个点，我们可以思考一下HashSet是如何实现存储不重复元素的</p>
<blockquote>
<p>由于源代码putVal巨抽象，这里就简单讲讲</p>
</blockquote>
<p>首先从创建讲起，假设你现在创建了一个HashSet集合</p>
<p>那么在底层，会顺带创建一个HashMap数组用于存储，一般而言，这个数组桶个数为16个（这个值是默认值，可以修改的）</p>
<p>假设你往这个HashSet里面添加一个值，那么这个值会先使用<code>hashcode()</code>得到一个值，在经过一些系列处理后得到桶索引，这个索引将告诉我们添加的这个值应该被放到哪个桶里面</p>
<blockquote>
<p>至于怎么计算出这个桶索引的，就太复杂了，涉及到一系列杂七杂八乱七八糟的操作，这里就不补充了</p>
</blockquote>
<p>那么至此，这个值就得到了两个有意思的东西，分别是它的<strong>哈希值</strong>（通过hashcode()）获得，还有是它的<strong>桶索引</strong>（通过获取到哈希值后经过一系列操作得到）</p>
<p>假设我们需要往里面再添加一个新的值，则会继续这一步操作</p>
<p>此时如果我们试图添加一个与之前添加的值相同的值，那么会发生什么呢？</p>
<p>依旧进行之前的步骤，首先是计算其哈希值，以及其桶索引，在将要把这个值放进去桶的时候，会先将这个元素的哈希值进行比较，如果这个值与桶里面元素的哈希值都不相同，则添加进桶里面</p>
<p>那么如果相等就可以直接丢掉吗？</p>
<p>当然不是！有时候哈希值相同值却不同，所以这个时候还需要<code>equals()</code>方法来检测其是否相同</p>
<p>如果相同，则不添加；如果不相同，则添加进桶里面去</p>
<h4 id="补充点：哈希冲突后处理"><a href="#补充点：哈希冲突后处理" class="headerlink" title="补充点：哈希冲突后处理"></a>补充点：哈希冲突后处理</h4><p>接下来将讲一下哈希冲突</p>
<p>在上面的补充点中我们提到一个点：不同元素的哈希值经过计算转换成桶索引后会出现相同的情况</p>
<p>这就是<strong>哈希冲突</strong>，说白了就是：一个桶里面塞了不止一个东西</p>
<p>那么HashSet（根本上讲应该是HashMap）是怎么处理的呢？</p>
<p>首先，假设我们在一个桶里面塞了超过7个元素，那么此时HashSet会直接将桶的数量翻倍（假设为默认的16，那么就变成32个桶了）</p>
<p>由于桶索引的计算与桶的个数是相关的，所以这里会重新分配桶</p>
<p>诶，这里就有人要说了，假设又塞满了呢？</p>
<p>如果此处又出现了一个桶里面塞的元素超过7个，那么会继续翻倍桶的数量</p>
<p>那么是不是就这样一直翻倍下去呢？</p>
<p>肯定不是，如果桶的数量大于64个，仍然出现了一个桶装了超过7个，那么会把这个桶从链表转换为红黑树</p>
<p>利用这种方法来增加查找效率</p>
<p>那么是不是意味着只有一个桶里面塞了大于7个元素才会翻倍桶数量呢？</p>
<p><strong>当然不是</strong>，HashMap里面有个东西叫做<strong>负载因子</strong>，这玩意的机制是，如果总元素的数量大于<code>总桶数 * 负载因子</code>，那么也会触发桶翻倍的机制</p>
<p>比如我在一个桶里面塞了4个，另一个桶塞了5个，另一个塞了6个，那么此时总元素个数为15个，大于<code>总桶数 * 负载因子</code>（16 * 0.75 &#x3D; 12）</p>
<p>那么此时即使任何一个桶没有大于7个元素，也会触发桶数翻倍</p>
<p>而一般默认的负载因子为：<strong>0.75</strong>，多了少了都不行，少了触发太快，多了的话冲突又过多，查询的时间复杂度直接变为<strong>O(n)</strong></p>
<p>所以，这里选择0.75是折中的选择</p>
<p>最后总结一下：</p>
<p>触发桶数翻倍需满足以下两点中的任意一点：</p>
<ol>
<li>总元素数大于 <code>总桶数 * 负载因子</code>（负载因子默认为0.75）</li>
<li>单个桶的元素数量大于7，并且此时总桶数小于64</li>
</ol>
<p>触发链表转红黑树（只有满足条件的桶才转换）</p>
<ol>
<li>单个桶的元素数量大于7，并且此时总桶数大于64</li>
</ol>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>接下来讲讲TreeSet</p>
<p>TreeSet是一个很有意思的实现类</p>
<p>这个实现类的特点就是会将这个类中的元素自动排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(treeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [2, 3, 6, 8, 9, 10, 11, 13]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，即使将生成的随机数字填入这个数组中，输出的时候依旧会按顺序输出</p>
<p>这也体现了这个类的特点：对输入的元素自动排序</p>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>接下来介绍一下TreeSet特有的方法，这些方法主要实现<code>SortedSet</code>接口和<code>NavigableSet</code>接口</p>
<p>首先讲讲<code>SortedSet</code>接口中实现的方法：</p>
<p><strong>first() &amp; last()</strong><br>这个方法的作用为返回第一个元素（最低）和返回最后一个元素（最高）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> treeSet.first();</span><br><span class="line"><span class="type">int</span> <span class="variable">higher</span> <span class="operator">=</span> treeSet.last();</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组最低元素为：%d，最高元素为：%d&quot;</span>,lower,higher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[0, 2, 5, 8, 9, 11, 12, 18, 19]</span></span><br><span class="line"><span class="comment">// 该数组最低元素为：0，最高元素为：19</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在分别对该数组使用first()方法和last()方法后，相对应的值变成了其最低项和最高项</p>
<p><strong>headSet()</strong><br>接下来是headSet()方法</p>
<p>这个方法拥有1个可填参数：<code>headSet(E toElement)</code></p>
<p>其中参数<code>toElement</code>代表规定的范围</p>
<p>这个方法的作用是限制只有小于括号内的参数（toElement）才可以输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">SortedSet&lt;Integer&gt; headset = treeSet.headSet(<span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组中小于数的有：%s&quot;</span>,headset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[2, 3, 5, 10, 17, 19]</span></span><br><span class="line"><span class="comment">// 该数组中小于数的有：[2, 3, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>tailSet()</strong><br>既然有小于，那就一定有大于，<code>tailSet()</code>便是返回大于括号内参数的数的方法</p>
<p>这个方法的同样拥有一个参数：<code>tailSet(E fromElement)</code></p>
<p>与上文的headSet()一致，这里也是用于限制范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">SortedSet&lt;Integer&gt; headset = treeSet.tailSet(<span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组中大于数的有：%s&quot;</span>,headset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[1, 3, 5, 6, 8, 9, 10, 12, 13, 17]</span></span><br><span class="line"><span class="comment">// 该数组中大于数的有：[10, 12, 13, 17]</span></span><br></pre></td></tr></table></figure>

<p><strong>subSet()</strong><br>既然有查找小于的<code>headSet()</code>，也有查找大于的<code>tailSet()</code></p>
<p>自然而然的便有可以返回指定数字范围的方法：<code>subSet()</code></p>
<p>这个方法有两个参数：<code>subSet(E fromElement, E toElement)</code></p>
<p>第一个<code>fromElement</code>，代表最低的元素大小，而第二个参数<code>toElement</code>，代表了最高的元素大小</p>
<p>需要注意的一点是，这个参数的范围为<strong>左闭右开区间</strong></p>
<p>接下来给出实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">SortedSet&lt;Integer&gt; subSet = treeSet.subSet(<span class="number">10</span>,<span class="number">15</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组中位于固定范围的数有：%s&quot;</span>,subSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[1, 2, 3, 4, 7, 12, 14, 15, 19]</span></span><br><span class="line"><span class="comment">// 该数组中位于固定范围的数有：[12, 14]</span></span><br></pre></td></tr></table></figure>

<p>接下来是<code>NavigableSet</code>接口的内容</p>
<p><strong>lower() &amp; higher()</strong><br>接下来是这两个方法</p>
<p>首先第一个方法<code>lower()</code>的作用是返回最大不小于该数的数，例如规定数字为10，则返回所有比10小的数中最大的那个数</p>
<p>第二个方法<code>higher()</code>的作用与<code>lower()</code>类似，返回最小不小于该数的数，例如规定数字为10，则返回所有比10大的数中最小的数</p>
<p>这两个方法都拥有一个可填的参数：<code>lower(E e)</code>、<code>higher(E e)</code></p>
<p>其中<code>参数e</code>分别代表最大不能超过这个数字的数，以及最小不能小于这个数的数</p>
<p>接下来看看具体用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> treeSet.lower(<span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组小于规定数的数字中最大的是：%s&quot;</span>,lower);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[6, 8, 10, 11, 14, 18]</span></span><br><span class="line"><span class="comment">// 该数组小于规定数的数字中最大的是：8</span></span><br></pre></td></tr></table></figure>
<p><code>higher()</code>的用法与之类似，这里不再演示</p>
<p>需要注意的一点是，这里的数字只能小于或大于规定的数，<strong>不可以等于</strong>，相当于开区间</p>
<hr>
<p><strong>floor() &amp; ceiling()</strong><br>接下来是这个方法</p>
<p>这两个方法的参数都只有一个：<code>floor(E e)</code>和<code>ceiling(E e)</code></p>
<p>其中<code>参数e</code>代表最大或最小可以选取到的数字</p>
<p><code>floot()</code>和<code>ceiling()</code>方法与上文的<code>lower()</code>和<code>higher()</code>方法类似，不过区别是<code>floot()</code>方法和<code>ceiling()</code>方法是闭区间而<code>lower()</code>方法和<code>higher()</code>方法都是开区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">floor</span> <span class="operator">=</span> treeSet.floor(<span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组中大于等于规定数的有：%s&quot;</span>,floor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[5, 6, 7, 8, 10, 11, 12, 13]</span></span><br><span class="line"><span class="comment">// 该数组中大于等于规定数的有：10</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在该程序中，<code>floor()</code>选取的标准是大于等于括号内最小（最接近）的数</p>
<p>而<code>ceiling()</code>也是相同的道理</p>
<p><strong>headSet() &amp; tailSet &amp; subSet()</strong><br>由于<code>NavigableSet接口</code>继承与<code>SortedSet接口</code>，所以这个接口也有<code>SortedSet接口</code>的一些方法</p>
<p>那么重复定义是不是过于冗余呢？其实不然，在<code>NavigableSet接口</code>中，这三个方法要比父接口要更加灵活</p>
<p>接下来介绍<code>NavigableSet接口</code>中的<code>headSet()</code>、<code>tailSet()</code>、<code>subSet()</code>方法</p>
<p>首先这三个方法的具体功能与<code>SortedSet接口</code>是一致的，所以此处不再次介绍</p>
<p>不一样的是，这三个方法都多了一到两个可选参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headSet(E toElement, <span class="type">boolean</span> inclusive)</span><br><span class="line"></span><br><span class="line">tailSet(E fromElement, <span class="type">boolean</span> inclusive)</span><br><span class="line"></span><br><span class="line">subSet(E fromElement, <span class="type">boolean</span> fromInclusive, E toElement, <span class="type">boolean</span> toInclusive)</span><br></pre></td></tr></table></figure>

<p>通过其类型为<code>boolean</code>便可以简单推断这个参数的作用</p>
<p>没错，便是使其可以<strong>自由调整</strong>为开闭区间</p>
<p>这一点便与其父接口不一致了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">NavigableSet&lt;Integer&gt; headset = treeSet.headSet(<span class="number">10</span>,<span class="literal">true</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组中小于等于数的有：%s&quot;</span>,headset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[5, 6, 9, 10, 11, 13, 14, 18, 19]</span></span><br><span class="line"><span class="comment">// 该数组中小于等于数的有：[5, 6, 9, 10]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里设定为<code>true</code>，输出也包括了规定的数字</p>
<p>而<code>subSet()</code>的参数有两个是决定范围的，分别决定前后数字为开闭区间</p>
<h5 id="补充点：源码中有趣的事情"><a href="#补充点：源码中有趣的事情" class="headerlink" title="补充点：源码中有趣的事情"></a>补充点：源码中有趣的事情</h5><p>如果你曾阅读过<code>TreeSet.java</code>中有关这部分的内容</p>
<p>那么你会发现一件事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> headSet(toElement, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里<code>SortedSet&lt;E&gt; headSet(E toElement)</code>返回的结果刚好是下面的<code>NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive)</code>，只不过将第二个决定开闭区间的参数固定为<code>false</code></p>
<p>而<code>subSet()</code>也有类似的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> subSet(fromElement, <span class="literal">true</span>, toElement, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里默认便为左闭右开区间</p>
<h5 id="补充点：关于多态"><a href="#补充点：关于多态" class="headerlink" title="补充点：关于多态"></a>补充点：关于多态</h5><p>在上文提及到：<code>NavigableSet接口</code>继承与<code>SortedSet接口</code>，也就是说，下面这种语法也是正确的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Integer&gt; headset = treeSet.headSet(<span class="number">10</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这里使用到了面向对象中的多态：<strong>父类&#x2F;接口引用指向子类&#x2F;实现类对象</strong></p>
<hr>
<p><strong>pollFirst() &amp; pollLast()</strong><br><code>pollFirst()</code>和<code>pollLast()</code>是两个相对应的方法，作用为<strong>移除并返回首项 &#x2F; 末项</strong></p>
<p>这两个方法均没有可填的参数</p>
<p>接下来看看具体例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;该数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">pollFirst</span> <span class="operator">=</span> treeSet.pollFirst();</span><br><span class="line">System.out.printf(<span class="string">&quot;使用pollFirst()方法移除了首项：%s\n&quot;</span>,pollFirst);</span><br><span class="line">System.out.printf(<span class="string">&quot;移除后数组为：%s\n&quot;</span>,treeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 该数组为：[3, 4, 6, 10, 11, 13, 15, 18]</span></span><br><span class="line"><span class="comment">// 使用pollFirst()方法移除了首项：3</span></span><br><span class="line"><span class="comment">// 移除后数组为：[4, 6, 10, 11, 13, 15, 18]</span></span><br></pre></td></tr></table></figure>
<p>另一个方法<code>pollLast()</code>则为移除并返回末项</p>
<p><strong>descendingSet()</strong><br>接下来是这个方法</p>
<p>这个方法依旧没有参数可以选择</p>
<p>这个方法的作用是反转数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;原数组为：%s\n&quot;</span>, treeSet);</span><br><span class="line">NavigableSet&lt;Integer&gt; reverseTreeSet = treeSet.descendingSet();</span><br><span class="line">System.out.printf(<span class="string">&quot;反转后数组为：%s\n&quot;</span>, reverseTreeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 原数组为：[8, 9, 10, 12, 14, 16, 17]</span></span><br><span class="line"><span class="comment">// 反转后数组为：[17, 16, 14, 12, 10, 9, 8]</span></span><br></pre></td></tr></table></figure>

<h5 id="补充点：与reverse-方法的区别"><a href="#补充点：与reverse-方法的区别" class="headerlink" title="补充点：与reverse()方法的区别"></a>补充点：与reverse()方法的区别</h5><p>看到这个方法可能会有人想到另一个方法：<code>reverse()</code></p>
<p>这两个方法都可以做到反转数组的功能，那么有什么差别呢？</p>
<p>一个最简单的差别就是加入时间</p>
<p><code>descendingSet()</code>在Java 6便加入了，而<code>reverse()</code>直到Java 21才加入</p>
<p>不过有意思的一点在源代码上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> NavigableSet&lt;E&gt; <span class="title function_">reversed</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.descendingSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的reversed()方法其实就是复用descendingSet()方法</p>
<p>诶，这是为什么呢？其实在Java 21中新增了一个接口<code>SequencedCollection</code>，这个接口又被<code>NavigableSet接口</code>继承，这个接口有个可以返回反转数列的方法（也就是<code>reversed()</code>），但是原本就有一个方法——<code>descendingSet()</code>，再次实现多少有点不太方便，所以便复用了这个方法</p>
<h4 id="补充点：定义排序规则"><a href="#补充点：定义排序规则" class="headerlink" title="补充点：定义排序规则"></a>补充点：定义排序规则</h4><blockquote>
<p>注意！！！！！<br>由于自定义排序规则的方法太多了！！！此处仅演示Lambda表达式的方法</p>
</blockquote>
<p>接下来是自定义排序规则</p>
<p>诶，那么要怎么自定义排序规则呢</p>
<p>其实很简单，只需要在创建的时候在<code>TreeSet&lt;&gt;()</code>后面的圆括号上加上对应的规则即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">TreeSet&lt;Integer&gt; sequentialTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b) -&gt; a - b);</span><br><span class="line">TreeSet&lt;Integer&gt; reverseTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b) -&gt; b - a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   sequentialTreeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">   reverseTreeSet.add(random.nextInt(<span class="number">0</span>,<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;使用正序规则：%s\n&quot;</span>,sequentialTreeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;使用倒序规则：%s\n&quot;</span>,reverseTreeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用正序规则：[5, 7, 11, 13, 14, 15, 17, 19]</span></span><br><span class="line"><span class="comment">// 使用倒序规则：[19, 17, 14, 13, 11, 8, 6, 4, 3, 1]</span></span><br></pre></td></tr></table></figure>

<h5 id="安全的排序规则"><a href="#安全的排序规则" class="headerlink" title="安全的排序规则"></a>安全的排序规则</h5><p>在圆括号内部的是<strong>lambda表达式</strong>，这样存在一个十分严重的问题，如果两者的差过大(一个整数a减一个负数b)，可能会导致溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; sequentialTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b) -&gt; a - b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   sequentialTreeSet.add(<span class="number">2147483647</span>);</span><br><span class="line">   sequentialTreeSet.add(-<span class="number">2147483648</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;使用正序规则：%s\n&quot;</span>,sequentialTreeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用正序规则：[2147483647, -2147483648]</span></span><br></pre></td></tr></table></figure>
<p>由于比较规则为前后相减，原本应为<code>4294967295</code>，但这个值溢出了，变成了-1</p>
<p>如果为负数，那么就意味着前面的数比后面的数小，但我们这个情况，正常应该是正数在前</p>
<p>那要怎么解决这个问题呢？其实很简单，我们可以使用到<strong>静态工厂方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; sequentialTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   sequentialTreeSet.add(<span class="number">2147483647</span>);</span><br><span class="line">   sequentialTreeSet.add(-<span class="number">2147483648</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;使用正序规则：%s\n&quot;</span>,sequentialTreeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用正序规则：[-2147483648, 2147483647]</span></span><br></pre></td></tr></table></figure>
<p>这种写法还有一些类似的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对应包的compare</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Integer::compare)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Comparator.naturalOrder()</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.naturalOrder())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接不填！因为不填算是自然排序，等价于上文的naturalOrder()</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;()</span><br></pre></td></tr></table></figure>

<hr>
<p>我们还可以给出一些更加自定义的规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">comparatorRule</span> <span class="operator">=</span></span><br><span class="line">         Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder());</span><br><span class="line"><span class="type">var</span> <span class="variable">comparatorRuleReversed</span> <span class="operator">=</span></span><br><span class="line">         (Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder())).reversed();</span><br><span class="line"></span><br><span class="line">TreeSet&lt;String&gt; sequentialTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparatorRule);</span><br><span class="line">TreeSet&lt;String&gt; reverseTreeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparatorRuleReversed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">randomInt</span> <span class="operator">=</span> String.valueOf(random.nextInt(<span class="number">0</span>, <span class="number">999999</span>));</span><br><span class="line">   sequentialTreeSet.add(randomInt);</span><br><span class="line">   reverseTreeSet.add(randomInt);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;排序规则为字符长度：\n&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;使用正序规则：%s\n&quot;</span>, sequentialTreeSet);</span><br><span class="line">System.out.printf(<span class="string">&quot;使用倒序规则：%s\n&quot;</span>, reverseTreeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 使用正序规则：[82100, 213078, 484793, 858731, 965938]</span></span><br><span class="line"><span class="comment">// 使用倒序规则：[965938, 858731, 484793, 213078, 82100]</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的比较规则是先比较字符串长度，再用自然规则（naturalOrder）进行排序</p>
<h5 id="自定义类排序"><a href="#自定义类排序" class="headerlink" title="自定义类排序"></a>自定义类排序</h5><p>除此之外，还可以使用自定义类来排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> productPrice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(String productName, <span class="type">int</span> productPrice)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.productName = productName;</span><br><span class="line">        <span class="built_in">this</span>.productPrice = productPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getProductPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProductName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetLearning</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        TreeSet&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparingInt(Product::getProductPrice));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomPrice</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>,<span class="number">3000</span>);</span><br><span class="line">            products.add(<span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;货物&quot;</span> + (i+<span class="number">1</span>), randomPrice));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后商品价格为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Product lst : products)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;商品：%s， 价格：%s\n&quot;</span>,lst.getProductName(),lst.getProductPrice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 商品：货物3， 价格：1079</span></span><br><span class="line"><span class="comment">// 商品：货物1， 价格：1659</span></span><br><span class="line"><span class="comment">// 商品：货物4， 价格：2003</span></span><br><span class="line"><span class="comment">// 商品：货物2， 价格：2027</span></span><br><span class="line"><span class="comment">// 商品：货物5， 价格：2938</span></span><br></pre></td></tr></table></figure>
<p>接下来开始解析这段代码：</p>
<p>首先第一个部分，这里新建了一个类：<code>Product</code></p>
<p>这个类里面定义了两个属性：<code>productName</code>和<code>productPrice</code></p>
<p>这两个属性分别记录商品的名字和商品的价格</p>
<p>接下来看到声明<code>TreeSet</code>中的自定义排序规则部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator.comparingInt(Product::getProductPrice)</span><br></pre></td></tr></table></figure>

<p>此处使用了这个规则，括号内部是一个匿名函数，意思是使用<code>Product</code>的<code>getProductPrice</code>的返回值进行比较</p>
<p>而前面的<code>Comparator.comparingInt</code>意思是比较的内容为数字</p>
<p>又因为<code>getProductPrice</code>的返回值为数字（productPrice），所以是合法的</p>
<p>当然这里有个小问题，如果价格相等是不会加入的</p>
<p>所以需要在这个规则后面加上一句，如果相等则比较其他的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.comparingInt(Product::getProductPrice)</span><br><span class="line">      .thenComparing(Product::getProductName));</span><br></pre></td></tr></table></figure>
<p>此处由于类中只有名字还可以用，所以就使用名字作为第二个比较的标准</p>
<blockquote>
<p>实际上还可以再继续比较下去：<br>Comparator.comparingInt(…).thenComparing(…).thenComparing(…)<br>不过没有什么意义就对了</p>
</blockquote>
<p>这种格式的写法为<strong>静态工厂</strong>写法，更加安全</p>
<h5 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h5><p>如果数组存在null值，不加处理会导致报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(<span class="number">123</span>);</span><br><span class="line">   treeSet.add(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;数组排序后：%s\n&quot;</span>,treeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里的报错为<code>NullPointerException</code></p>
<p>那要怎么办呢？其实很简单，只需要在排序规则那里加入如何处理<code>null</code>值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Comparator.nullsFirst(Integer::compare));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   treeSet.add(<span class="number">123</span>);</span><br><span class="line">   treeSet.add(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;数组排序后：%s\n&quot;</span>,treeSet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 数组排序后：[null, 123]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处使用Integer::compareTo也可以，本质上compareTo就是调用compare<br>可以看到，这里使用了<code>Comparator.nullsFirst(Integer::compare)</code>，用于将null值放到最前面</p>
</blockquote>
<p>除此以外还有<code>nullsLast</code>，用于将null值放到最后面</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>作者:</span>
                        <span>Gaizhedu</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Java/"># Java</a>
                    
                        <a href="/tags/WIP/"># WIP</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">返回</a>
                <span>· </span>
                <a href="/">主页</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/12/31/css3/">CSS3 属性</a>
            
            
            <a class="next" rel="next" href="/2025/10/23/k&r_ch6/">C程序设计语言（K&R）第六章</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Gaizhedu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>